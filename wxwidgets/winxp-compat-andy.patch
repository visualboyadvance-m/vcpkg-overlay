diff -Nur wxWidgets-master/include/wx/msw/private/filedialog.h wxWidgets-master_patched/include/wx/msw/private/filedialog.h
--- wxWidgets-master/include/wx/msw/private/filedialog.h        2025-06-01 00:48:27.000000000 +0200
+++ wxWidgets-master_patched/include/wx/msw/private/filedialog.h        2025-06-01 08:34:57.644682000 +0200
@@ -18,8 +18,8 @@
 // Using IFileOpenDialog requires a compiler providing declarations and
 // definitions of interfaces available in Windows Vista.
 // And it needs OLE support to actually use these interfaces.
-#if (wxUSE_DIRDLG || wxUSE_FILEDLG) && wxUSE_OLE && \
-    defined(__IFileOpenDialog_INTERFACE_DEFINED__)
+#if ((wxUSE_DIRDLG || wxUSE_FILEDLG) && wxUSE_OLE && \
+    defined(__IFileOpenDialog_INTERFACE_DEFINED__)) && (_WIN32_WINNT >= 0x0600)
     #define wxUSE_IFILEOPENDIALOG 1
 #else
     #define wxUSE_IFILEOPENDIALOG 0

diff -Nur master-5d36349708.clean/include/wx/datetimectrl.h master-5d36349708.clean_patched/include/wx/datetimectrl.h
--- master-5d36349708.clean/include/wx/datetimectrl.h	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/include/wx/datetimectrl.h	2025-05-27 18:52:24.266487800 +0200
@@ -14,7 +14,7 @@
 
 #if wxUSE_DATEPICKCTRL || wxUSE_TIMEPICKCTRL
 
-#define wxNEEDS_DATETIMEPICKCTRL
+#undef wxNEEDS_DATETIMEPICKCTRL
 
 #include "wx/control.h"         // the base class
 
diff -Nur master-5d36349708.clean/include/wx/msw/msgdlg.h master-5d36349708.clean_patched/include/wx/msw/msgdlg.h
--- master-5d36349708.clean/include/wx/msw/msgdlg.h	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/include/wx/msw/msgdlg.h	2025-05-27 19:09:45.793587800 +0200
@@ -2,6 +2,7 @@
 // Name:        wx/msw/msgdlg.h
 // Purpose:     wxMessageDialog class
 // Author:      Julian Smart
+// Modified by:
 // Created:     01/02/97
 // Copyright:   (c) Julian Smart
 // Licence:     wxWindows licence
@@ -20,12 +21,12 @@
                     const wxPoint& WXUNUSED(pos) = wxDefaultPosition)
         : wxMessageDialogBase(parent, message, caption, style)
     {
-        m_hook = nullptr;
+        m_hook = NULL;
     }
 
-    virtual int ShowModal() override;
+    virtual int ShowModal() wxOVERRIDE;
 
-    virtual long GetEffectiveIcon() const override;
+    virtual long GetEffectiveIcon() const wxOVERRIDE;
 
     // implementation-specific
 
@@ -34,7 +35,7 @@
 
 protected:
     // Override this as task dialogs are always centered on parent.
-    virtual void DoCentre(int dir) override;
+    virtual void DoCentre(int dir) wxOVERRIDE;
 
 private:
     // hook procedure used to adjust the message box beyond what the standard
diff -Nur master-5d36349708.clean/include/wx/msw/private/msgdlg.h master-5d36349708.clean_patched/include/wx/msw/private/msgdlg.h
--- master-5d36349708.clean/include/wx/msw/private/msgdlg.h	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/include/wx/msw/private/msgdlg.h	2025-05-27 19:22:12.915282900 +0200
@@ -13,10 +13,19 @@
 #include "wx/msw/wrapcctl.h"
 #include "wx/scopedarray.h"
 
+// Macro to help identify if task dialogs are available: we rely on
+// TD_WARNING_ICON being defined in the headers for this as this symbol is used
+// by the task dialogs only. Also notice that task dialogs are available for
+// Unicode applications only.
+#if defined(TD_WARNING_ICON) && wxUSE_UNICODE
+    #define wxHAS_MSW_TASKDIALOG
+#endif
+
 // Provides methods for creating a task dialog.
 namespace wxMSWMessageDialog
 {
 
+#ifdef wxHAS_MSW_TASKDIALOG
     class wxMSWTaskDialogConfig
     {
     public:
@@ -24,7 +33,7 @@
 
         wxMSWTaskDialogConfig()
             : buttons(new TASKDIALOG_BUTTON[MAX_BUTTONS]),
-              parent(nullptr),
+              parent(NULL),
               iconId(0),
               style(0),
               useCustomLabels(false)
@@ -65,15 +74,15 @@
     typedef HRESULT (WINAPI *TaskDialogIndirect_t)(const TASKDIALOGCONFIG *,
                                                    int *, int *, BOOL *);
 
-    // Return the pointer to TaskDialogIndirect(). It can return a null pointer
-    // if the task dialog is not available, which may happen even under modern
-    // OS versions when using comctl32.dll v5, as it happens if the application
-    // doesn't provide a manifest specifying that it wants to use v6.
+    // Return the pointer to TaskDialogIndirect(). This should only be called
+    // if HasNativeTaskDialog() returned true and is normally guaranteed to
+    // succeed in this case.
     TaskDialogIndirect_t GetTaskDialogIndirectFunc();
+#endif // wxHAS_MSW_TASKDIALOG
+
 
-    // Return true if the task dialog is available, but we don't actually need
-    // to show it yet (if we do, then GetTaskDialogIndirectFunc() should be
-    // used directly).
+    // Check if the task dialog is available: this simply checks the OS version
+    // as we know that it's only present in Vista and later.
     bool HasNativeTaskDialog();
 
     // Translates standard MSW button IDs like IDCANCEL into an equivalent
diff -Nur master-5d36349708.clean/src/msw/darkmode.cpp master-5d36349708.clean_patched/src/msw/darkmode.cpp
--- master-5d36349708.clean/src/msw/darkmode.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/darkmode.cpp	2025-05-27 18:33:07.797240500 +0200
@@ -28,7 +28,7 @@
 // Allow predefining this as 0 to disable dark mode support completely.
 #ifndef wxUSE_DARK_MODE
     // Otherwise enable it by default.
-    #define wxUSE_DARK_MODE 1
+    #define wxUSE_DARK_MODE 0
 #endif
 
 #if wxUSE_DARK_MODE
diff -Nur master-5d36349708.clean/src/msw/dirdlg.cpp master-5d36349708.clean_patched/src/msw/dirdlg.cpp
--- master-5d36349708.clean/src/msw/dirdlg.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/dirdlg.cpp	2025-05-27 18:35:03.161876300 +0200
@@ -29,6 +29,7 @@
 #endif
 
 #include "wx/msw/private/filedialog.h"
+#include "wx/msw/private/gethwnd.h"
 
 #if wxUSE_IFILEOPENDIALOG
 
diff -Nur master-5d36349708.clean/src/msw/hyperlink.cpp master-5d36349708.clean_patched/src/msw/hyperlink.cpp
--- master-5d36349708.clean/src/msw/hyperlink.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/hyperlink.cpp	2025-05-27 18:49:48.278071600 +0200
@@ -174,9 +174,11 @@
 
 bool wxHyperlinkCtrl::MSWAreCustomColoursEnabled() const
 {
+#if _WIN32_WINNT >= 0x0600
     LITEM litem = { };
     litem.mask = LIF_ITEMINDEX | LIF_STATE;
     litem.stateMask = LIS_DEFAULTCOLORS;
+
     if ( !::SendMessage(GetHwnd(), LM_GETITEM, 0, (LPARAM)&litem) )
     {
         wxLogDebug("LM_GETITEM(LIS_DEFAULTCOLORS) unexpectedly failed");
@@ -184,10 +186,14 @@
     }
 
     return (litem.state & LIS_DEFAULTCOLORS) != 0;
+#else
+    return false;
+#endif
 }
 
 void wxHyperlinkCtrl::MSWEnableCustomColours()
 {
+#if _WIN32_WINNT >= 0x0600
     // By default, the native control ignores the colours we set for it, so we
     // need to explicitly enable this for them to be used.
     if ( !MSWAreCustomColoursEnabled() )
@@ -199,6 +205,7 @@
         if ( !::SendMessage(GetHwnd(), LM_SETITEM, 0, (LPARAM)&litem) )
             wxLogDebug("LM_SETITEM(LIS_DEFAULTCOLORS) unexpectedly failed");
     }
+#endif
 }
 
 wxColour wxHyperlinkCtrl::GetHoverColour() const
diff -Nur master-5d36349708.clean/src/msw/msgdlg.cpp master-5d36349708.clean_patched/src/msw/msgdlg.cpp
--- master-5d36349708.clean/src/msw/msgdlg.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/msgdlg.cpp	2025-05-27 19:08:42.098507300 +0200
@@ -2,6 +2,7 @@
 // Name:        src/msw/msgdlg.cpp
 // Purpose:     wxMessageDialog
 // Author:      Julian Smart
+// Modified by:
 // Created:     04/01/98
 // Copyright:   (c) Julian Smart
 // Licence:     wxWindows licence
@@ -19,12 +20,12 @@
     #include "wx/intl.h"
     #include "wx/utils.h"
     #include "wx/msw/private.h"
+    #include "wx/hashmap.h"
 #endif
 
 #include "wx/ptr_scpd.h"
 #include "wx/dynlib.h"
 #include "wx/msw/private/button.h"
-#include "wx/msw/private/darkmode.h"
 #include "wx/msw/private/metrics.h"
 #include "wx/msw/private/msgdlg.h"
 #include "wx/modalhook.h"
@@ -43,6 +44,14 @@
 
 wxIMPLEMENT_CLASS(wxMessageDialog, wxDialog);
 
+// there can potentially be one message box per thread so we use a hash map
+// with thread ids as keys and (currently shown) message boxes as values
+//
+// TODO: replace this with wxTLS once it's available
+WX_DECLARE_HASH_MAP(unsigned long, wxMessageDialog *,
+                    wxIntegerHash, wxIntegerEqual,
+                    wxMessageDialogMap);
+
 // the order in this array is the one in which buttons appear in the
 // message box
 const wxMessageDialog::ButtonAccessors wxMessageDialog::ms_buttons[] =
@@ -56,9 +65,12 @@
 namespace
 {
 
-// Different threads could potentially show message boxes at the same time, so
-// remember the window showing it in a thread-specific variable.
-thread_local wxMessageDialog* gs_currentDialog = nullptr;
+wxMessageDialogMap& HookMap()
+{
+    static wxMessageDialogMap s_Map;
+
+    return s_Map;
+}
 
 /*
     All this code is used for adjusting the message box layout when we mess
@@ -74,7 +86,10 @@
 void ScreenRectToClient(HWND hwnd, RECT& rc)
 {
     // map from desktop (i.e. screen) coordinates to ones of this window
-    wxMapWindowPoints(HWND_DESKTOP, hwnd, &rc);
+    //
+    // notice that a RECT is laid out as 2 consecutive POINTs so the cast is
+    // valid
+    ::MapWindowPoints(HWND_DESKTOP, hwnd, reinterpret_cast<POINT *>(&rc), 2);
 }
 
 // set window position to the given rect
@@ -101,9 +116,13 @@
 WXLRESULT wxCALLBACK
 wxMessageDialog::HookFunction(int code, WXWPARAM wParam, WXLPARAM lParam)
 {
-    // Get the thread-local instance of wxMessageDialog
-    wxMessageDialog *  const wnd = gs_currentDialog;
-    wxCHECK_MSG( wnd, false, "No valid wxMessageDialog?" );
+    // Find the thread-local instance of wxMessageDialog
+    const DWORD tid = ::GetCurrentThreadId();
+    wxMessageDialogMap::iterator node = HookMap().find(tid);
+    wxCHECK_MSG( node != HookMap().end(), false,
+                    wxT("bogus thread id in wxMessageDialog::Hook") );
+
+    wxMessageDialog *  const wnd = node->second;
 
     const HHOOK hhook = (HHOOK)wnd->m_hook;
     const LRESULT rc = ::CallNextHookEx(hhook, code, wParam, lParam);
@@ -112,8 +131,8 @@
     {
         // we won't need this hook any longer
         ::UnhookWindowsHookEx(hhook);
-        wnd->m_hook = nullptr;
-        gs_currentDialog = nullptr;
+        wnd->m_hook = NULL;
+        HookMap().erase(tid);
 
         TempHWNDSetter set(wnd, (WXHWND)wParam);
 
@@ -150,9 +169,9 @@
     // find the static control to replace: normally there are two of them, the
     // icon and the text itself so search for all of them and ignore the icon
     // ones
-    HWND hwndStatic = ::FindWindowEx(GetHwnd(), nullptr, wxT("STATIC"), nullptr);
+    HWND hwndStatic = ::FindWindowEx(GetHwnd(), NULL, wxT("STATIC"), NULL);
     if ( ::GetWindowLong(hwndStatic, GWL_STYLE) & SS_ICON )
-        hwndStatic = ::FindWindowEx(GetHwnd(), hwndStatic, wxT("STATIC"), nullptr);
+        hwndStatic = ::FindWindowEx(GetHwnd(), hwndStatic, wxT("STATIC"), NULL);
 
     if ( !hwndStatic )
     {
@@ -217,9 +236,9 @@
                         rc.left, rc.top,
                         rc.right - rc.left, rc.bottom - rc.top,
                         GetHwnd(),
-                        nullptr,
+                        NULL,
                         wxGetInstance(),
-                        nullptr
+                        NULL
                       );
 
     if ( !hwndEdit )
@@ -396,7 +415,7 @@
 
     // use the top level window as parent if none specified
     m_parent = GetParentForModalDialog();
-    HWND hWnd = m_parent ? GetHwndOf(m_parent) : nullptr;
+    HWND hWnd = m_parent ? GetHwndOf(m_parent) : NULL;
 
 #if wxUSE_INTL
     // native message box always uses the current user locale but the program
@@ -502,8 +521,8 @@
     // control with an edit one)
     const DWORD tid = ::GetCurrentThreadId();
     m_hook = ::SetWindowsHookEx(WH_CBT,
-                                &wxMessageDialog::HookFunction, nullptr, tid);
-    gs_currentDialog = this;
+                                &wxMessageDialog::HookFunction, NULL, tid);
+    HookMap()[tid] = this;
 
     // do show the dialog
     const int msAns = MessageBox
@@ -523,14 +542,18 @@
 
     wxWindowDisabler disableOthers(this, GetParentForModalDialog());
 
-    if ( TaskDialogIndirect_t taskDialogIndirect = GetTaskDialogIndirectFunc() )
+#ifdef wxHAS_MSW_TASKDIALOG
+    if ( HasNativeTaskDialog() )
     {
+        TaskDialogIndirect_t taskDialogIndirect = GetTaskDialogIndirectFunc();
+        wxCHECK_MSG( taskDialogIndirect, wxID_CANCEL, wxS("no task dialog?") );
+
         WinStruct<TASKDIALOGCONFIG> tdc;
         wxMSWTaskDialogConfig wxTdc( *this );
         wxTdc.MSWCommonTaskDialogInit( tdc );
 
         int msAns;
-        HRESULT hr = taskDialogIndirect( &tdc, &msAns, nullptr, nullptr );
+        HRESULT hr = taskDialogIndirect( &tdc, &msAns, NULL, NULL );
         if ( FAILED(hr) )
         {
             wxLogApiError( "TaskDialogIndirect", hr );
@@ -549,6 +572,7 @@
 
         return MSWTranslateReturnCode( msAns );
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return ShowMessageBox();
 }
@@ -567,11 +591,13 @@
 
 void wxMessageDialog::DoCentre(int dir)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     // Task dialog is always centered on its parent window and trying to center
     // it manually doesn't work because its HWND is not created yet so don't
     // even try as this would only result in (debug) error messages.
     if ( HasNativeTaskDialog() )
         return;
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxMessageDialogBase::DoCentre(dir);
 }
@@ -580,23 +606,7 @@
 // Helpers of the wxMSWMessageDialog namespace
 // ----------------------------------------------------------------------------
 
-namespace
-{
-
-HRESULT CALLBACK
-wxTaskDialogCallback(HWND hwnd, UINT msg, WPARAM, LPARAM, LONG_PTR)
-{
-    switch ( msg )
-    {
-        case TDN_DIALOG_CONSTRUCTED:
-            wxMSWDarkMode::EnableForTLW(hwnd);
-            break;
-    }
-
-    return S_OK;
-}
-
-} // anonymous namespace
+#ifdef wxHAS_MSW_TASKDIALOG
 
 wxMSWTaskDialogConfig::wxMSWTaskDialogConfig(const wxMessageDialogBase& dlg)
                      : buttons(new TASKDIALOG_BUTTON[MAX_BUTTONS])
@@ -652,7 +662,7 @@
     tdc.pszWindowTitle = caption.t_str();
 
     // use the top level window as parent if none specified
-    tdc.hwndParent = parent ? GetHwndOf(parent) : nullptr;
+    tdc.hwndParent = parent ? GetHwndOf(parent) : NULL;
 
     if ( wxApp::MSWGetDefaultLayout(parent) == wxLayout_RightToLeft )
         tdc.dwFlags |= TDF_RTL_LAYOUT;
@@ -746,8 +756,6 @@
 
         AddTaskDialogButton(tdc, IDHELP, 0 /* not used */, btnHelpLabel);
     }
-
-    tdc.pfCallback = wxTaskDialogCallback;
 }
 
 void wxMSWTaskDialogConfig::AddTaskDialogButton(TASKDIALOGCONFIG &tdc,
@@ -781,7 +789,7 @@
 
 TaskDialogIndirect_t wxMSWMessageDialog::GetTaskDialogIndirectFunc()
 {
-    // Initialize the function pointer to an invalid value different from nullptr
+    // Initialize the function pointer to an invalid value different from NULL
     // to avoid reloading comctl32.dll and trying to resolve it every time
     // we're called if task dialog is not available (notice that this may
     // happen even under Vista+ if we don't use comctl32.dll v6).
@@ -800,9 +808,19 @@
     return s_TaskDialogIndirect;
 }
 
+#endif // wxHAS_MSW_TASKDIALOG
+
 bool wxMSWMessageDialog::HasNativeTaskDialog()
 {
-    return wxMSWMessageDialog::GetTaskDialogIndirectFunc() != nullptr;
+#ifdef wxHAS_MSW_TASKDIALOG
+    if ( wxGetWinVersion() >= wxWinVersion_6 )
+    {
+        if ( wxMSWMessageDialog::GetTaskDialogIndirectFunc() )
+            return true;
+    }
+#endif // wxHAS_MSW_TASKDIALOG
+
+    return false;
 }
 
 int wxMSWMessageDialog::MSWTranslateReturnCode(int msAns)
diff -Nur master-5d36349708.clean/src/msw/renderer.cpp master-5d36349708.clean_patched/src/msw/renderer.cpp
--- master-5d36349708.clean/src/msw/renderer.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/renderer.cpp	2025-05-27 18:25:36.478025400 +0200
@@ -1006,11 +1006,6 @@
     {
         RECT rc = ConvertToRECT(dc, rect);
 
-        DTTOPTS textOpts;
-        textOpts.dwSize = sizeof(textOpts);
-        textOpts.dwFlags = DTT_STATEID;
-        textOpts.iStateId = itemState;
-
         wxColour textColour = dc.GetTextForeground();
         if (flags & wxCONTROL_SELECTED)
         {
@@ -1021,11 +1016,6 @@
             textColour = wxSystemSettings::GetColour(wxSYS_COLOUR_GRAYTEXT);
         }
 
-        if (textColour.IsOk()) {
-            textOpts.dwFlags |= DTT_TEXTCOLOR;
-            textOpts.crText = textColour.GetPixel();
-        }
-
         const DWORD defTextFlags = DT_NOPREFIX;
         DWORD textFlags = defTextFlags;
 
@@ -1179,8 +1169,8 @@
                 break;
         }
 
-        ::DrawThemeTextEx(hTheme, dc.GetHDC(), LVP_LISTITEM, itemState,
-                            drawText->wchar_str(), -1, textFlags, &rc, &textOpts);
+        ::DrawThemeText(hTheme, dc.GetHDC(), LVP_LISTITEM, itemState,
+                            drawText->wchar_str(), -1, textFlags, 0, &rc);
     }
     else
     {
diff -Nur master-5d36349708.clean/src/msw/richmsgdlg.cpp master-5d36349708.clean_patched/src/msw/richmsgdlg.cpp
--- master-5d36349708.clean/src/msw/richmsgdlg.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/richmsgdlg.cpp	2025-05-27 18:46:14.700627000 +0200
@@ -10,6 +10,8 @@
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
+#undef wxUSE_RICHMSGDLG
+
 #if wxUSE_RICHMSGDLG
 
 #include "wx/richmsgdlg.h"
diff -Nur master-5d36349708.clean/src/msw/taskbar.cpp master-5d36349708.clean_patched/src/msw/taskbar.cpp
--- master-5d36349708.clean/src/msw/taskbar.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/taskbar.cpp	2025-05-27 18:31:46.424484700 +0200
@@ -251,7 +251,9 @@
     if ( icon.IsOk() )
     {
         m_balloonIcon = icon.GetIconFor(m_win);
+#if _WIN32_WINNT >= 0x0600
         notifyData.hBalloonIcon = GetHiconOf(m_balloonIcon);
+#endif
         notifyData.dwInfoFlags |= NIIF_USER | NIIF_LARGE_ICON;
     }
     else if ( flags & wxICON_INFORMATION )
diff -Nur master-5d36349708.clean/src/msw/toolbar.cpp master-5d36349708.clean_patched/src/msw/toolbar.cpp
--- master-5d36349708.clean/src/msw/toolbar.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/toolbar.cpp	2025-05-27 18:47:46.550980700 +0200
@@ -1702,7 +1702,9 @@
 
                 *result = CDRF_DODEFAULT |
                           CDRF_NOTIFYPOSTPAINT |
+#if _WIN32_WINNT >= 0x0600
                           TBCDRF_USECDCOLORS |
+#endif
                           TBCDRF_HILITEHOTTRACK;
 
                 // Draw custom checked button background when it is not hot:
diff -Nur master-5d36349708.clean/src/msw/uilocale.cpp master-5d36349708.clean_patched/src/msw/uilocale.cpp
--- master-5d36349708.clean/src/msw/uilocale.cpp	2025-05-27 19:25:21.123132300 +0200
+++ master-5d36349708.clean_patched/src/msw/uilocale.cpp	2025-05-27 18:19:55.135303900 +0200
@@ -325,7 +325,7 @@
             ULONG numberOfLanguages = 0;
             ULONG bufferSize = 0;
 
-            BOOL (WINAPI *pfnGetUserPreferredUILanguage)(DWORD, PULONG, PZZWSTR, PULONG) =
+            BOOL (WINAPI *pfnGetUserPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG) =
                 (BOOL (*)(DWORD, PULONG, PZZWSTR, PULONG))kernel32.GetSymbol(wxT("GetUserPreferredUILanguages"));
 
             if (pfnGetUserPreferredUILanguages(MUI_LANGUAGE_NAME, &numberOfLanguages, nullptr, &bufferSize))
@@ -378,7 +378,7 @@
             {
                 wxLogLastError(wxT("GetLocaleInfo"));
             }
-    <S-Del>    }
+        }
 
         return preferred;
     }
@@ -440,6 +440,10 @@
 
     void Use() override
     {
+        wxDynamicLibrary kernel32(wxT("kernel32.dll"), wxDL_VERBATIM | wxDL_DEFAULT);
+	BOOL (WINAPI *pfnSetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG) =
+             (BOOL (*)(DWORD, PCZZWSTR, PULONG))kernel32.GetSymbol(wxT("SetThreadPreferredUILanguages"));
+
         // Construct a double NUL-terminated buffer.
         wchar_t buf[256];
         if ( m_name )
@@ -450,8 +454,8 @@
 
         ULONG num = 1;
 
-        if ( !::SetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, buf, &num) )
-            wxLogLastError(wxT("SetThreadPreferredUILanguages"));
+        if (pfnSetThreadPreferredUILanguages)
+            pfnSetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, buf, &num);
     }
 
     wxString GetName() const override
@@ -601,8 +605,8 @@
               LOCALE_SDAYNAME4, LOCALE_SDAYNAME5, LOCALE_SDAYNAME6 },
             { LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1, LOCALE_SABBREVDAYNAME2, LOCALE_SABBREVDAYNAME3,
               LOCALE_SABBREVDAYNAME4, LOCALE_SABBREVDAYNAME5, LOCALE_SABBREVDAYNAME6 },
-            { LOCALE_SSHORTESTDAYNAME7, LOCALE_SSHORTESTDAYNAME1, LOCALE_SSHORTESTDAYNAME2, LOCALE_SSHORTESTDAYNAME3,
-              LOCALE_SSHORTESTDAYNAME4, LOCALE_SSHORTESTDAYNAME5, LOCALE_SSHORTESTDAYNAME6 }
+            { LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1, LOCALE_SABBREVDAYNAME2, LOCALE_SABBREVDAYNAME3,
+              LOCALE_SABBREVDAYNAME4, LOCALE_SABBREVDAYNAME5, LOCALE_SABBREVDAYNAME6 }
         };
 
         const int idx = ArrayIndexFromFlag(form.GetFlags());
diff -Nur master-5d36349708.clean/src/msw/utilsgui.cpp master-5d36349708.clean_patched/src/msw/utilsgui.cpp
--- master-5d36349708.clean/src/msw/utilsgui.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/utilsgui.cpp	2025-05-27 18:26:38.634813900 +0200
@@ -279,8 +279,13 @@
             break;
 
         case UseType::Peak:
+#if _WIN32_WINNT >= 0x0600
             flagsGDI = GR_GDIOBJECTS_PEAK;
             flagsUSER = GR_USEROBJECTS_PEAK;
+#else
+            flagsGDI = GR_GDIOBJECTS;
+            flagsUSER = GR_USEROBJECTS;
+#endif
             break;
     }
 
diff -Nur master-5d36349708.clean/src/msw/window.cpp master-5d36349708.clean_patched/src/msw/window.cpp
--- master-5d36349708.clean/src/msw/window.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-5d36349708.clean_patched/src/msw/window.cpp	2025-05-27 18:30:59.114989800 +0200
@@ -286,10 +286,14 @@
 // This only works for the current (i.e. last received) mouse event.
 static bool wxIsTouchEventMSW()
 {
+#if _WIN32_WINNT >= 0x0601
     // From https://learn.microsoft.com/en-us/windows/win32/tablet/system-events-and-mouse-messages
     const LONG_PTR MI_WP_SIGNATURE = 0xFF515700;
     const LONG_PTR SIGNATURE_MASK = 0xFFFFFF00;
     return (::GetMessageExtraInfo() & SIGNATURE_MASK) == MI_WP_SIGNATURE;
+#else
+    return false;
+#endif
 }
 
 // ---------------------------------------------------------------------------
@@ -889,6 +893,7 @@
 
 bool wxWindowMSW::EnableTouchEvents(int eventsMask)
 {
+#if _WIN32_WINNT >= 0x0601
     // Static struct used when we need to use just a single configuration.
     GESTURECONFIG config = {0, 0, 0};
 
@@ -1006,6 +1011,9 @@
     }
 
     return true;
+#else
+    return false;
+#endif
 }
 
 void wxWindowMSW::MSWUpdateUIState(int action, int state)
@@ -3481,6 +3489,7 @@
             }
             break;
 
+#if _WIN32_WINNT >= 0x0601
         case WM_GESTURE:
         {
             HGESTUREINFO hGestureInfo = reinterpret_cast<HGESTUREINFO>(lParam);
@@ -3559,6 +3568,7 @@
             // handled, otherwise we still pass them to DefWindowProc().
             processed = HandleTouch(wParam, lParam);
             break;
+#endif
 
         // CTLCOLOR messages are sent by children to query the parent for their
         // colors
@@ -6205,6 +6215,7 @@
                                    const wxPoint& pt,
                                    WXDWORD flags)
 {
+#if _WIN32_WINNT >= 0x0601
     event.SetEventObject(this);
     event.SetTimestamp(::GetMessageTime());
     event.SetPosition(pt);
@@ -6216,10 +6227,14 @@
         event.SetGestureEnd();
 
     return (flags & GF_BEGIN) != 0;
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandlePanGesture(const wxPoint& pt, WXDWORD flags)
 {
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_GESTURE_PAN
     wxPanGestureEvent event(GetId());
 
@@ -6240,12 +6255,16 @@
     s_previousLocation = pt;
 
     return HandleWindowEvent(event);
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleZoomGesture(const wxPoint& pt,
                                     WXDWORD fingerDistance,
                                     WXDWORD flags)
 {
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_GESTURE_ZOOM
     wxZoomGestureEvent event(GetId());
 
@@ -6278,12 +6297,16 @@
     s_previousLocation = pt;
 
     return HandleWindowEvent(event);
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleRotateGesture(const wxPoint& pt,
                                       WXDWORD angleArgument,
                                       WXDWORD flags)
 {
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_GESTURE_ROTATE
     wxRotateGestureEvent event(GetId());
 
@@ -6312,29 +6335,41 @@
     }
 
     return HandleWindowEvent(event);
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleTwoFingerTap(const wxPoint& pt, WXDWORD flags)
 {
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_TWO_FINGER_TAP
     wxTwoFingerTapEvent event(GetId());
 
     InitGestureEvent(event, pt, flags);
 
     return HandleWindowEvent(event);
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandlePressAndTap(const wxPoint& pt, WXDWORD flags)
 {
+#if _WIN32_WINNT >= 0x0601
     wxPressAndTapEvent event(GetId());
 
     InitGestureEvent(event, pt, flags);
 
     return HandleWindowEvent(event);
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleTouch(WXWPARAM wParam, WXLPARAM lParam)
 {
+#if _WIN32_WINNT >= 0x0601
     const unsigned count = LOWORD(wParam);
     const HTOUCHINPUT hTouchInput = (HTOUCHINPUT)lParam;
     wxVector<TOUCHINPUT> info(count);
@@ -6376,6 +6411,9 @@
     }
 
     return allHandled;
+#else
+    return false;
+#endif
 }
 
 // ---------------------------------------------------------------------------
--- master-d724c6b5c3.clean/src/msw/darkmode.cpp	2025-05-27 19:36:29.041953200 +0200
+++ master-d724c6b5c3.clean_patched/src/msw/darkmode.cpp	2025-05-27 20:58:06.912195100 +0200
@@ -28,7 +28,7 @@
 // Allow predefining this as 0 to disable dark mode support completely.
 #ifndef wxUSE_DARK_MODE
     // Otherwise enable it by default.
-    #define wxUSE_DARK_MODE 0
+    #define wxUSE_DARK_MODE 1
 #endif
 
 #if wxUSE_DARK_MODE
@@ -682,19 +682,13 @@
                 // We have to specify the text colour explicitly as by default
                 // black would be used, making the menu label unreadable on the
                 // (almost) black background.
-                DTTOPTS textOpts;
-                textOpts.dwSize = sizeof(textOpts);
-                textOpts.dwFlags = DTT_TEXTCOLOR;
-                textOpts.crText = wxColourToRGB(GetMenuColour(colText));
-
                 DWORD drawTextFlags = DT_CENTER | DT_SINGLELINE | DT_VCENTER;
                 if ( itemState & ODS_NOACCEL)
                     drawTextFlags |= DT_HIDEPREFIX;
 
                 wxUxThemeHandle menuTheme(w, L"Menu");
-                ::DrawThemeTextEx(menuTheme, dis.hDC, MENU_BARITEM, partState,
-                                  buf, mii.cch, drawTextFlags, rcItem,
-                                  &textOpts);
+                ::DrawThemeText(menuTheme, dis.hDC, 0, partState,
+                                  buf, mii.cch, drawTextFlags, 0, rcItem);
             }
             return true;
     }
--- master-dee097c397.clean/src/msw/darkmode.cpp	2025-05-28 09:24:52.396375000 +0200
+++ master-dee097c397.clean_patched/src/msw/darkmode.cpp	2025-05-28 09:23:09.525999900 +0200
@@ -32,7 +32,6 @@
 #endif
 
 #if wxUSE_DARK_MODE
-
 #ifndef WX_PRECOMP
     #include "wx/app.h"
     #include "wx/bitmap.h"
@@ -54,6 +53,22 @@
 
 #include <memory>
 
+#ifndef MBI_NORMAL
+#define MBI_NORMAL 1
+#endif
+
+#ifndef MBI_HOT
+#define MBI_HOT 2
+#endif
+
+#ifndef MBI_DISABLED
+#define MBI_DISABLED 4
+#endif
+
+#ifndef MBI_DISABLEDHOT
+#define MBI_DISABLEDHOT 5
+#endif
+
 #if wxUSE_LOG_TRACE
 static const char* TRACE_DARKMODE = "msw-darkmode";
 #endif // wxUSE_LOG_TRACE
diff -Nur master-0db0e17733.clean/include/wx/datetimectrl.h master-ea316f385b.clean_patched/include/wx/datetimectrl.h
--- master-0db0e17733.clean/include/wx/datetimectrl.h	2025-05-28 11:22:44.307425000 +0200
+++ master-ea316f385b.clean_patched/include/wx/datetimectrl.h	2025-05-28 09:28:45.976992400 +0200
@@ -14,7 +14,7 @@
 
 #if wxUSE_DATEPICKCTRL || wxUSE_TIMEPICKCTRL
 
-#undef wxNEEDS_DATETIMEPICKCTRL
+#define wxNEEDS_DATETIMEPICKCTRL 1
 
 #include "wx/control.h"         // the base class
 
diff -Nur master-0db0e17733.clean/include/wx/msw/msgdlg.h master-ea316f385b.clean_patched/include/wx/msw/msgdlg.h
--- master-0db0e17733.clean/include/wx/msw/msgdlg.h	2025-05-28 11:22:44.307425000 +0200
+++ master-ea316f385b.clean_patched/include/wx/msw/msgdlg.h	2025-05-28 09:28:45.976992400 +0200
@@ -2,7 +2,7 @@
 // Name:        wx/msw/msgdlg.h
 // Purpose:     wxMessageDialog class
 // Author:      Julian Smart
-// Modified by:
+// Modified by:
 // Created:     01/02/97
 // Copyright:   (c) Julian Smart
 // Licence:     wxWindows licence
@@ -21,12 +21,12 @@
                     const wxPoint& WXUNUSED(pos) = wxDefaultPosition)
         : wxMessageDialogBase(parent, message, caption, style)
     {
-        m_hook = NULL;
+        m_hook = NULL;
     }
 
-    virtual int ShowModal() wxOVERRIDE;
+    virtual int ShowModal() wxOVERRIDE;
 
-    virtual long GetEffectiveIcon() const wxOVERRIDE;
+    virtual long GetEffectiveIcon() const wxOVERRIDE;
 
     // implementation-specific
 
@@ -35,7 +35,7 @@
 
 protected:
     // Override this as task dialogs are always centered on parent.
-    virtual void DoCentre(int dir) wxOVERRIDE;
+    virtual void DoCentre(int dir) wxOVERRIDE;
 
 private:
     // hook procedure used to adjust the message box beyond what the standard
diff -Nur master-0db0e17733.clean/include/wx/msw/private/msgdlg.h master-ea316f385b.clean_patched/include/wx/msw/private/msgdlg.h
--- master-0db0e17733.clean/include/wx/msw/private/msgdlg.h	2025-05-28 11:22:44.307425000 +0200
+++ master-ea316f385b.clean_patched/include/wx/msw/private/msgdlg.h	2025-05-28 09:28:45.976992400 +0200
@@ -13,19 +13,19 @@
 #include "wx/msw/wrapcctl.h"
 #include "wx/scopedarray.h"
 
-// Macro to help identify if task dialogs are available: we rely on
-// TD_WARNING_ICON being defined in the headers for this as this symbol is used
-// by the task dialogs only. Also notice that task dialogs are available for
-// Unicode applications only.
-#if defined(TD_WARNING_ICON) && wxUSE_UNICODE
-    #define wxHAS_MSW_TASKDIALOG
-#endif
-
+// Macro to help identify if task dialogs are available: we rely on
+// TD_WARNING_ICON being defined in the headers for this as this symbol is used
+// by the task dialogs only. Also notice that task dialogs are available for
+// Unicode applications only.
+#if defined(TD_WARNING_ICON) && wxUSE_UNICODE
+    #define wxHAS_MSW_TASKDIALOG
+#endif
+
 // Provides methods for creating a task dialog.
 namespace wxMSWMessageDialog
 {
 
-#ifdef wxHAS_MSW_TASKDIALOG
+#ifdef wxHAS_MSW_TASKDIALOG
     class wxMSWTaskDialogConfig
     {
     public:
@@ -33,7 +33,7 @@
 
         wxMSWTaskDialogConfig()
             : buttons(new TASKDIALOG_BUTTON[MAX_BUTTONS]),
-              parent(NULL),
+              parent(NULL),
               iconId(0),
               style(0),
               useCustomLabels(false)
@@ -74,15 +74,15 @@
     typedef HRESULT (WINAPI *TaskDialogIndirect_t)(const TASKDIALOGCONFIG *,
                                                    int *, int *, BOOL *);
 
-    // Return the pointer to TaskDialogIndirect(). This should only be called
-    // if HasNativeTaskDialog() returned true and is normally guaranteed to
-    // succeed in this case.
+    // Return the pointer to TaskDialogIndirect(). This should only be called
+    // if HasNativeTaskDialog() returned true and is normally guaranteed to
+    // succeed in this case.
     TaskDialogIndirect_t GetTaskDialogIndirectFunc();
-#endif // wxHAS_MSW_TASKDIALOG
-
+#endif // wxHAS_MSW_TASKDIALOG
+
 
-    // Check if the task dialog is available: this simply checks the OS version
-    // as we know that it's only present in Vista and later.
+    // Check if the task dialog is available: this simply checks the OS version
+    // as we know that it's only present in Vista and later.
     bool HasNativeTaskDialog();
 
     // Translates standard MSW button IDs like IDCANCEL into an equivalent
diff -Nur master-0db0e17733.clean/include/wx/msw/richmsgdlg.h master-ea316f385b.clean_patched/include/wx/msw/richmsgdlg.h
--- master-0db0e17733.clean/include/wx/msw/richmsgdlg.h	2025-05-26 18:04:50.000000000 +0200
+++ master-ea316f385b.clean_patched/include/wx/msw/richmsgdlg.h	2025-05-28 11:19:53.005649800 +0200
@@ -13,15 +13,16 @@
 class WXDLLIMPEXP_CORE wxRichMessageDialog : public wxGenericRichMessageDialog
 {
 public:
-    wxRichMessageDialog(wxWindow *parent,
-                        const wxString& message,
-                        const wxString& caption = wxASCII_STR(wxMessageBoxCaptionStr),
-                        long style = wxOK | wxCENTRE)
+    wxRichMessageDialog(wxWindow* parent,
+        const wxString& message,
+        const wxString& caption = wxASCII_STR(wxMessageBoxCaptionStr),
+        long style = wxOK | wxCENTRE)
         : wxGenericRichMessageDialog(parent, message, caption, style)
-        { }
+    {
+    }
 
     // overridden base class method showing the native task dialog if possible
-    virtual int ShowModal() override;
+    virtual int ShowModal() wxOVERRIDE;
 
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxRichMessageDialog);
diff -Nur master-0db0e17733.clean/src/msw/darkmode.cpp master-ea316f385b.clean_patched/src/msw/darkmode.cpp
--- master-0db0e17733.clean/src/msw/darkmode.cpp	2025-05-28 11:22:44.323601600 +0200
+++ master-ea316f385b.clean_patched/src/msw/darkmode.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -28,7 +28,7 @@
 // Allow predefining this as 0 to disable dark mode support completely.
 #ifndef wxUSE_DARK_MODE
     // Otherwise enable it by default.
-    #define wxUSE_DARK_MODE 1
+    #define wxUSE_DARK_MODE 1
 #endif
 
 #if wxUSE_DARK_MODE
@@ -53,22 +53,22 @@
 
 #include <memory>
 
-#ifndef MBI_NORMAL
-#define MBI_NORMAL 1
-#endif
-
-#ifndef MBI_HOT
-#define MBI_HOT 2
-#endif
-
-#ifndef MBI_DISABLED
-#define MBI_DISABLED 4
-#endif
-
-#ifndef MBI_DISABLEDHOT
-#define MBI_DISABLEDHOT 5
-#endif
-
+#ifndef MBI_NORMAL
+#define MBI_NORMAL 1
+#endif
+
+#ifndef MBI_HOT
+#define MBI_HOT 2
+#endif
+
+#ifndef MBI_DISABLED
+#define MBI_DISABLED 4
+#endif
+
+#ifndef MBI_DISABLEDHOT
+#define MBI_DISABLEDHOT 5
+#endif
+
 #if wxUSE_LOG_TRACE
 static const char* TRACE_DARKMODE = "msw-darkmode";
 #endif // wxUSE_LOG_TRACE
@@ -702,8 +702,8 @@
                     drawTextFlags |= DT_HIDEPREFIX;
 
                 wxUxThemeHandle menuTheme(w, L"Menu");
-                ::DrawThemeText(menuTheme, dis.hDC, 0, partState,
-                                  buf, mii.cch, drawTextFlags, 0, rcItem);
+                ::DrawThemeText(menuTheme, dis.hDC, 0, partState,
+                                  buf, mii.cch, drawTextFlags, 0, rcItem);
             }
             return true;
     }
diff -Nur master-0db0e17733.clean/src/msw/dirdlg.cpp master-ea316f385b.clean_patched/src/msw/dirdlg.cpp
--- master-0db0e17733.clean/src/msw/dirdlg.cpp	2025-05-28 11:22:44.313556800 +0200
+++ master-ea316f385b.clean_patched/src/msw/dirdlg.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -29,7 +29,7 @@
 #endif
 
 #include "wx/msw/private/filedialog.h"
-#include "wx/msw/private/gethwnd.h"
+#include "wx/msw/private/gethwnd.h"
 
 #if wxUSE_IFILEOPENDIALOG
 
diff -Nur master-0db0e17733.clean/src/msw/hyperlink.cpp master-ea316f385b.clean_patched/src/msw/hyperlink.cpp
--- master-0db0e17733.clean/src/msw/hyperlink.cpp	2025-05-28 11:22:44.313556800 +0200
+++ master-ea316f385b.clean_patched/src/msw/hyperlink.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -174,11 +174,11 @@
 
 bool wxHyperlinkCtrl::MSWAreCustomColoursEnabled() const
 {
-#if _WIN32_WINNT >= 0x0600
+#if _WIN32_WINNT >= 0x0600
     LITEM litem = { };
     litem.mask = LIF_ITEMINDEX | LIF_STATE;
     litem.stateMask = LIS_DEFAULTCOLORS;
-
+
     if ( !::SendMessage(GetHwnd(), LM_GETITEM, 0, (LPARAM)&litem) )
     {
         wxLogDebug("LM_GETITEM(LIS_DEFAULTCOLORS) unexpectedly failed");
@@ -186,14 +186,14 @@
     }
 
     return (litem.state & LIS_DEFAULTCOLORS) != 0;
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 void wxHyperlinkCtrl::MSWEnableCustomColours()
 {
-#if _WIN32_WINNT >= 0x0600
+#if _WIN32_WINNT >= 0x0600
     // By default, the native control ignores the colours we set for it, so we
     // need to explicitly enable this for them to be used.
     if ( !MSWAreCustomColoursEnabled() )
@@ -205,7 +205,7 @@
         if ( !::SendMessage(GetHwnd(), LM_SETITEM, 0, (LPARAM)&litem) )
             wxLogDebug("LM_SETITEM(LIS_DEFAULTCOLORS) unexpectedly failed");
     }
-#endif
+#endif
 }
 
 wxColour wxHyperlinkCtrl::GetHoverColour() const
diff -Nur master-0db0e17733.clean/src/msw/msgdlg.cpp master-ea316f385b.clean_patched/src/msw/msgdlg.cpp
--- master-0db0e17733.clean/src/msw/msgdlg.cpp	2025-05-28 11:22:44.313556800 +0200
+++ master-ea316f385b.clean_patched/src/msw/msgdlg.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -2,7 +2,7 @@
 // Name:        src/msw/msgdlg.cpp
 // Purpose:     wxMessageDialog
 // Author:      Julian Smart
-// Modified by:
+// Modified by:
 // Created:     04/01/98
 // Copyright:   (c) Julian Smart
 // Licence:     wxWindows licence
@@ -20,7 +20,7 @@
     #include "wx/intl.h"
     #include "wx/utils.h"
     #include "wx/msw/private.h"
-    #include "wx/hashmap.h"
+    #include "wx/hashmap.h"
 #endif
 
 #include "wx/ptr_scpd.h"
@@ -44,14 +44,14 @@
 
 wxIMPLEMENT_CLASS(wxMessageDialog, wxDialog);
 
-// there can potentially be one message box per thread so we use a hash map
-// with thread ids as keys and (currently shown) message boxes as values
-//
-// TODO: replace this with wxTLS once it's available
-WX_DECLARE_HASH_MAP(unsigned long, wxMessageDialog *,
-                    wxIntegerHash, wxIntegerEqual,
-                    wxMessageDialogMap);
-
+// there can potentially be one message box per thread so we use a hash map
+// with thread ids as keys and (currently shown) message boxes as values
+//
+// TODO: replace this with wxTLS once it's available
+WX_DECLARE_HASH_MAP(unsigned long, wxMessageDialog *,
+                    wxIntegerHash, wxIntegerEqual,
+                    wxMessageDialogMap);
+
 // the order in this array is the one in which buttons appear in the
 // message box
 const wxMessageDialog::ButtonAccessors wxMessageDialog::ms_buttons[] =
@@ -65,12 +65,12 @@
 namespace
 {
 
-wxMessageDialogMap& HookMap()
-{
-    static wxMessageDialogMap s_Map;
-
-    return s_Map;
-}
+wxMessageDialogMap& HookMap()
+{
+    static wxMessageDialogMap s_Map;
+
+    return s_Map;
+}
 
 /*
     All this code is used for adjusting the message box layout when we mess
@@ -86,10 +86,10 @@
 void ScreenRectToClient(HWND hwnd, RECT& rc)
 {
     // map from desktop (i.e. screen) coordinates to ones of this window
-    //
-    // notice that a RECT is laid out as 2 consecutive POINTs so the cast is
-    // valid
-    ::MapWindowPoints(HWND_DESKTOP, hwnd, reinterpret_cast<POINT *>(&rc), 2);
+    //
+    // notice that a RECT is laid out as 2 consecutive POINTs so the cast is
+    // valid
+    ::MapWindowPoints(HWND_DESKTOP, hwnd, reinterpret_cast<POINT *>(&rc), 2);
 }
 
 // set window position to the given rect
@@ -116,13 +116,13 @@
 WXLRESULT wxCALLBACK
 wxMessageDialog::HookFunction(int code, WXWPARAM wParam, WXLPARAM lParam)
 {
-    // Find the thread-local instance of wxMessageDialog
-    const DWORD tid = ::GetCurrentThreadId();
-    wxMessageDialogMap::iterator node = HookMap().find(tid);
-    wxCHECK_MSG( node != HookMap().end(), false,
-                    wxT("bogus thread id in wxMessageDialog::Hook") );
-
-    wxMessageDialog *  const wnd = node->second;
+    // Find the thread-local instance of wxMessageDialog
+    const DWORD tid = ::GetCurrentThreadId();
+    wxMessageDialogMap::iterator node = HookMap().find(tid);
+    wxCHECK_MSG( node != HookMap().end(), false,
+                    wxT("bogus thread id in wxMessageDialog::Hook") );
+
+    wxMessageDialog *  const wnd = node->second;
 
     const HHOOK hhook = (HHOOK)wnd->m_hook;
     const LRESULT rc = ::CallNextHookEx(hhook, code, wParam, lParam);
@@ -131,8 +131,8 @@
     {
         // we won't need this hook any longer
         ::UnhookWindowsHookEx(hhook);
-        wnd->m_hook = NULL;
-        HookMap().erase(tid);
+        wnd->m_hook = NULL;
+        HookMap().erase(tid);
 
         TempHWNDSetter set(wnd, (WXHWND)wParam);
 
@@ -169,9 +169,9 @@
     // find the static control to replace: normally there are two of them, the
     // icon and the text itself so search for all of them and ignore the icon
     // ones
-    HWND hwndStatic = ::FindWindowEx(GetHwnd(), NULL, wxT("STATIC"), NULL);
+    HWND hwndStatic = ::FindWindowEx(GetHwnd(), NULL, wxT("STATIC"), NULL);
     if ( ::GetWindowLong(hwndStatic, GWL_STYLE) & SS_ICON )
-        hwndStatic = ::FindWindowEx(GetHwnd(), hwndStatic, wxT("STATIC"), NULL);
+        hwndStatic = ::FindWindowEx(GetHwnd(), hwndStatic, wxT("STATIC"), NULL);
 
     if ( !hwndStatic )
     {
@@ -236,9 +236,9 @@
                         rc.left, rc.top,
                         rc.right - rc.left, rc.bottom - rc.top,
                         GetHwnd(),
-                        NULL,
+                        NULL,
                         wxGetInstance(),
-                        NULL
+                        NULL
                       );
 
     if ( !hwndEdit )
@@ -415,7 +415,7 @@
 
     // use the top level window as parent if none specified
     m_parent = GetParentForModalDialog();
-    HWND hWnd = m_parent ? GetHwndOf(m_parent) : NULL;
+    HWND hWnd = m_parent ? GetHwndOf(m_parent) : NULL;
 
 #if wxUSE_INTL
     // native message box always uses the current user locale but the program
@@ -521,8 +521,8 @@
     // control with an edit one)
     const DWORD tid = ::GetCurrentThreadId();
     m_hook = ::SetWindowsHookEx(WH_CBT,
-                                &wxMessageDialog::HookFunction, NULL, tid);
-    HookMap()[tid] = this;
+                                &wxMessageDialog::HookFunction, NULL, tid);
+    HookMap()[tid] = this;
 
     // do show the dialog
     const int msAns = MessageBox
@@ -542,18 +542,18 @@
 
     wxWindowDisabler disableOthers(this, GetParentForModalDialog());
 
-#ifdef wxHAS_MSW_TASKDIALOG
-    if ( HasNativeTaskDialog() )
+#ifdef wxHAS_MSW_TASKDIALOG
+    if ( HasNativeTaskDialog() )
     {
-        TaskDialogIndirect_t taskDialogIndirect = GetTaskDialogIndirectFunc();
-        wxCHECK_MSG( taskDialogIndirect, wxID_CANCEL, wxS("no task dialog?") );
-
+        TaskDialogIndirect_t taskDialogIndirect = GetTaskDialogIndirectFunc();
+        wxCHECK_MSG( taskDialogIndirect, wxID_CANCEL, wxS("no task dialog?") );
+
         WinStruct<TASKDIALOGCONFIG> tdc;
         wxMSWTaskDialogConfig wxTdc( *this );
         wxTdc.MSWCommonTaskDialogInit( tdc );
 
         int msAns;
-        HRESULT hr = taskDialogIndirect( &tdc, &msAns, NULL, NULL );
+        HRESULT hr = taskDialogIndirect( &tdc, &msAns, NULL, NULL );
         if ( FAILED(hr) )
         {
             wxLogApiError( "TaskDialogIndirect", hr );
@@ -572,7 +572,7 @@
 
         return MSWTranslateReturnCode( msAns );
     }
-#endif // wxHAS_MSW_TASKDIALOG
+#endif // wxHAS_MSW_TASKDIALOG
 
     return ShowMessageBox();
 }
@@ -591,13 +591,13 @@
 
 void wxMessageDialog::DoCentre(int dir)
 {
-#ifdef wxHAS_MSW_TASKDIALOG
+#ifdef wxHAS_MSW_TASKDIALOG
     // Task dialog is always centered on its parent window and trying to center
     // it manually doesn't work because its HWND is not created yet so don't
     // even try as this would only result in (debug) error messages.
     if ( HasNativeTaskDialog() )
         return;
-#endif // wxHAS_MSW_TASKDIALOG
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxMessageDialogBase::DoCentre(dir);
 }
@@ -606,7 +606,7 @@
 // Helpers of the wxMSWMessageDialog namespace
 // ----------------------------------------------------------------------------
 
-#ifdef wxHAS_MSW_TASKDIALOG
+#ifdef wxHAS_MSW_TASKDIALOG
 
 wxMSWTaskDialogConfig::wxMSWTaskDialogConfig(const wxMessageDialogBase& dlg)
                      : buttons(new TASKDIALOG_BUTTON[MAX_BUTTONS])
@@ -662,7 +662,7 @@
     tdc.pszWindowTitle = caption.t_str();
 
     // use the top level window as parent if none specified
-    tdc.hwndParent = parent ? GetHwndOf(parent) : NULL;
+    tdc.hwndParent = parent ? GetHwndOf(parent) : NULL;
 
     if ( wxApp::MSWGetDefaultLayout(parent) == wxLayout_RightToLeft )
         tdc.dwFlags |= TDF_RTL_LAYOUT;
@@ -789,7 +789,7 @@
 
 TaskDialogIndirect_t wxMSWMessageDialog::GetTaskDialogIndirectFunc()
 {
-    // Initialize the function pointer to an invalid value different from NULL
+    // Initialize the function pointer to an invalid value different from NULL
     // to avoid reloading comctl32.dll and trying to resolve it every time
     // we're called if task dialog is not available (notice that this may
     // happen even under Vista+ if we don't use comctl32.dll v6).
@@ -808,19 +808,19 @@
     return s_TaskDialogIndirect;
 }
 
-#endif // wxHAS_MSW_TASKDIALOG
-
+#endif // wxHAS_MSW_TASKDIALOG
+
 bool wxMSWMessageDialog::HasNativeTaskDialog()
 {
-#ifdef wxHAS_MSW_TASKDIALOG
-    if ( wxGetWinVersion() >= wxWinVersion_6 )
-    {
-        if ( wxMSWMessageDialog::GetTaskDialogIndirectFunc() )
-            return true;
-    }
-#endif // wxHAS_MSW_TASKDIALOG
-
-    return false;
+#ifdef wxHAS_MSW_TASKDIALOG
+    if ( wxGetWinVersion() >= wxWinVersion_6 )
+    {
+        if ( wxMSWMessageDialog::GetTaskDialogIndirectFunc() )
+            return true;
+    }
+#endif // wxHAS_MSW_TASKDIALOG
+
+    return false;
 }
 
 int wxMSWMessageDialog::MSWTranslateReturnCode(int msAns)
diff -Nur master-0db0e17733.clean/src/msw/renderer.cpp master-ea316f385b.clean_patched/src/msw/renderer.cpp
--- master-0db0e17733.clean/src/msw/renderer.cpp	2025-05-28 11:22:44.313556800 +0200
+++ master-ea316f385b.clean_patched/src/msw/renderer.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -1169,8 +1169,8 @@
                 break;
         }
 
-        ::DrawThemeText(hTheme, dc.GetHDC(), LVP_LISTITEM, itemState,
-                            drawText->wchar_str(), -1, textFlags, 0, &rc);
+        ::DrawThemeText(hTheme, dc.GetHDC(), LVP_LISTITEM, itemState,
+                            drawText->wchar_str(), -1, textFlags, 0, &rc);
     }
     else
     {
diff -Nur master-0db0e17733.clean/src/msw/richmsgdlg.cpp master-ea316f385b.clean_patched/src/msw/richmsgdlg.cpp
--- master-0db0e17733.clean/src/msw/richmsgdlg.cpp	2025-05-28 11:22:44.317574600 +0200
+++ master-ea316f385b.clean_patched/src/msw/richmsgdlg.cpp	2025-05-28 11:18:29.523897900 +0200
@@ -10,18 +10,18 @@
 // For compilers that support precompilation, includes "wx.h".
 #include "wx/wxprec.h"
 
-#undef wxUSE_RICHMSGDLG
-
 #if wxUSE_RICHMSGDLG
 
 #include "wx/richmsgdlg.h"
 #include "wx/modalhook.h"
 
 #ifndef WX_PRECOMP
-    #include "wx/msw/private.h"
-    #include "wx/utils.h"                   // for wxWindowDisabler
+#include "wx/msw/private.h"
+#include "wx/utils.h"                   // for wxWindowDisabler
 #endif
 
+// This will define wxHAS_MSW_TASKDIALOG if we have support for it in the
+// headers we use.
 #include "wx/msw/private/msgdlg.h"
 
 // ----------------------------------------------------------------------------
@@ -32,9 +32,10 @@
 {
     WX_HOOK_MODAL_DIALOG();
 
+#ifdef wxHAS_MSW_TASKDIALOG
     using namespace wxMSWMessageDialog;
 
-    if ( HasNativeTaskDialog() )
+    if (HasNativeTaskDialog())
     {
         wxWindowDisabler disableOthers(this, GetParentForModalDialog());
 
@@ -42,52 +43,52 @@
         WinStruct<TASKDIALOGCONFIG> tdc;
         wxMSWTaskDialogConfig wxTdc(*this);
 
-        wxTdc.MSWCommonTaskDialogInit( tdc );
+        wxTdc.MSWCommonTaskDialogInit(tdc);
 
         // add a checkbox
-        if ( !m_checkBoxText.empty() )
+        if (!m_checkBoxText.empty())
         {
             tdc.pszVerificationText = m_checkBoxText.t_str();
-            if ( m_checkBoxValue )
+            if (m_checkBoxValue)
                 tdc.dwFlags |= TDF_VERIFICATION_FLAG_CHECKED;
         }
 
         // add collapsible footer
-        if ( !m_detailedText.empty() )
+        if (!m_detailedText.empty())
             tdc.pszExpandedInformation = m_detailedText.t_str();
 
         // Add footer text
-        if ( !m_footerText.empty() )
+        if (!m_footerText.empty())
         {
             tdc.pszFooter = m_footerText.t_str();
-            switch ( m_footerIcon )
+            switch (m_footerIcon)
             {
-                case wxICON_INFORMATION:
-                    tdc.pszFooterIcon = TD_INFORMATION_ICON;
-                    break;
-                case wxICON_WARNING:
-                    tdc.pszFooterIcon = TD_WARNING_ICON;
-                    break;
-                case wxICON_ERROR:
-                    tdc.pszFooterIcon = TD_ERROR_ICON;
-                    break;
-                case wxICON_AUTH_NEEDED:
-                    tdc.pszFooterIcon = TD_SHIELD_ICON;
-                    break;
+            case wxICON_INFORMATION:
+                tdc.pszFooterIcon = TD_INFORMATION_ICON;
+                break;
+            case wxICON_WARNING:
+                tdc.pszFooterIcon = TD_WARNING_ICON;
+                break;
+            case wxICON_ERROR:
+                tdc.pszFooterIcon = TD_ERROR_ICON;
+                break;
+            case wxICON_AUTH_NEEDED:
+                tdc.pszFooterIcon = TD_SHIELD_ICON;
+                break;
             }
         }
 
         TaskDialogIndirect_t taskDialogIndirect = GetTaskDialogIndirectFunc();
-        if ( !taskDialogIndirect )
+        if (!taskDialogIndirect)
             return wxID_CANCEL;
 
         // create the task dialog, process the answer and return it.
         BOOL checkBoxChecked;
         int msAns;
-        HRESULT hr = taskDialogIndirect( &tdc, &msAns, nullptr, &checkBoxChecked );
-        if ( FAILED(hr) )
+        HRESULT hr = taskDialogIndirect(&tdc, &msAns, NULL, &checkBoxChecked);
+        if (FAILED(hr))
         {
-            wxLogApiError( "TaskDialogIndirect", hr );
+            wxLogApiError("TaskDialogIndirect", hr);
             return wxID_CANCEL;
         }
         m_checkBoxValue = checkBoxChecked != FALSE;
@@ -96,14 +97,15 @@
         // "Cancel" button (see comment in MSWCommonTaskDialogInit). This
         // results in msAns being IDCANCEL while we want IDOK (just like
         // how the native MessageBox function does with only an "OK" button).
-        if ( (msAns == IDCANCEL)
-            && !(GetMessageDialogStyle() & (wxYES_NO|wxCANCEL)) )
+        if ((msAns == IDCANCEL)
+            && !(GetMessageDialogStyle() & (wxYES_NO | wxCANCEL)))
         {
             msAns = IDOK;
         }
 
-        return MSWTranslateReturnCode( msAns );
+        return MSWTranslateReturnCode(msAns);
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     // use the generic version when task dialog is't available at either
     // compile or run-time.
diff -Nur master-0db0e17733.clean/src/msw/taskbar.cpp master-ea316f385b.clean_patched/src/msw/taskbar.cpp
--- master-0db0e17733.clean/src/msw/taskbar.cpp	2025-05-28 11:22:44.317574600 +0200
+++ master-ea316f385b.clean_patched/src/msw/taskbar.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -251,9 +251,9 @@
     if ( icon.IsOk() )
     {
         m_balloonIcon = icon.GetIconFor(m_win);
-#if _WIN32_WINNT >= 0x0600
+#if _WIN32_WINNT >= 0x0600
         notifyData.hBalloonIcon = GetHiconOf(m_balloonIcon);
-#endif
+#endif
         notifyData.dwInfoFlags |= NIIF_USER | NIIF_LARGE_ICON;
     }
     else if ( flags & wxICON_INFORMATION )
diff -Nur master-0db0e17733.clean/src/msw/toolbar.cpp master-ea316f385b.clean_patched/src/msw/toolbar.cpp
--- master-0db0e17733.clean/src/msw/toolbar.cpp	2025-05-28 11:22:44.317574600 +0200
+++ master-ea316f385b.clean_patched/src/msw/toolbar.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -1702,9 +1702,9 @@
 
                 *result = CDRF_DODEFAULT |
                           CDRF_NOTIFYPOSTPAINT |
-#if _WIN32_WINNT >= 0x0600
+#if _WIN32_WINNT >= 0x0600
                           TBCDRF_USECDCOLORS |
-#endif
+#endif
                           TBCDRF_HILITEHOTTRACK;
 
                 // Draw custom checked button background when it is not hot:
diff -Nur master-0db0e17733.clean/src/msw/uilocale.cpp master-ea316f385b.clean_patched/src/msw/uilocale.cpp
--- master-0db0e17733.clean/src/msw/uilocale.cpp	2025-05-28 11:22:44.319584000 +0200
+++ master-ea316f385b.clean_patched/src/msw/uilocale.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -325,7 +325,7 @@
             ULONG numberOfLanguages = 0;
             ULONG bufferSize = 0;
 
-            BOOL (WINAPI *pfnGetUserPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG) =
+            BOOL (WINAPI *pfnGetUserPreferredUILanguages)(DWORD, PULONG, PZZWSTR, PULONG) =
                 (BOOL (*)(DWORD, PULONG, PZZWSTR, PULONG))kernel32.GetSymbol(wxT("GetUserPreferredUILanguages"));
 
             if (pfnGetUserPreferredUILanguages(MUI_LANGUAGE_NAME, &numberOfLanguages, nullptr, &bufferSize))
@@ -378,7 +378,7 @@
             {
                 wxLogLastError(wxT("GetLocaleInfo"));
             }
-        }
+        }
 
         return preferred;
     }
@@ -440,10 +440,10 @@
 
     void Use() override
     {
-        wxDynamicLibrary kernel32(wxT("kernel32.dll"), wxDL_VERBATIM | wxDL_DEFAULT);
-	BOOL (WINAPI *pfnSetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG) =
-             (BOOL (*)(DWORD, PCZZWSTR, PULONG))kernel32.GetSymbol(wxT("SetThreadPreferredUILanguages"));
-
+        wxDynamicLibrary kernel32(wxT("kernel32.dll"), wxDL_VERBATIM | wxDL_DEFAULT);
+	BOOL (WINAPI *pfnSetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG) =
+             (BOOL (*)(DWORD, PCZZWSTR, PULONG))kernel32.GetSymbol(wxT("SetThreadPreferredUILanguages"));
+
         // Construct a double NUL-terminated buffer.
         wchar_t buf[256];
         if ( m_name )
@@ -454,8 +454,8 @@
 
         ULONG num = 1;
 
-        if (pfnSetThreadPreferredUILanguages)
-            pfnSetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, buf, &num);
+        if (pfnSetThreadPreferredUILanguages)
+            pfnSetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, buf, &num);
     }
 
     wxString GetName() const override
@@ -605,8 +605,8 @@
               LOCALE_SDAYNAME4, LOCALE_SDAYNAME5, LOCALE_SDAYNAME6 },
             { LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1, LOCALE_SABBREVDAYNAME2, LOCALE_SABBREVDAYNAME3,
               LOCALE_SABBREVDAYNAME4, LOCALE_SABBREVDAYNAME5, LOCALE_SABBREVDAYNAME6 },
-            { LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1, LOCALE_SABBREVDAYNAME2, LOCALE_SABBREVDAYNAME3,
-              LOCALE_SABBREVDAYNAME4, LOCALE_SABBREVDAYNAME5, LOCALE_SABBREVDAYNAME6 }
+            { LOCALE_SABBREVDAYNAME7, LOCALE_SABBREVDAYNAME1, LOCALE_SABBREVDAYNAME2, LOCALE_SABBREVDAYNAME3,
+              LOCALE_SABBREVDAYNAME4, LOCALE_SABBREVDAYNAME5, LOCALE_SABBREVDAYNAME6 }
         };
 
         const int idx = ArrayIndexFromFlag(form.GetFlags());
diff -Nur master-0db0e17733.clean/src/msw/utilsgui.cpp master-ea316f385b.clean_patched/src/msw/utilsgui.cpp
--- master-0db0e17733.clean/src/msw/utilsgui.cpp	2025-05-28 11:22:44.319584000 +0200
+++ master-ea316f385b.clean_patched/src/msw/utilsgui.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -279,13 +279,13 @@
             break;
 
         case UseType::Peak:
-#if _WIN32_WINNT >= 0x0600
+#if _WIN32_WINNT >= 0x0600
             flagsGDI = GR_GDIOBJECTS_PEAK;
             flagsUSER = GR_USEROBJECTS_PEAK;
-#else
-            flagsGDI = GR_GDIOBJECTS;
-            flagsUSER = GR_USEROBJECTS;
-#endif
+#else
+            flagsGDI = GR_GDIOBJECTS;
+            flagsUSER = GR_USEROBJECTS;
+#endif
             break;
     }
 
diff -Nur master-0db0e17733.clean/src/msw/window.cpp master-ea316f385b.clean_patched/src/msw/window.cpp
--- master-0db0e17733.clean/src/msw/window.cpp	2025-05-28 11:22:44.321592200 +0200
+++ master-ea316f385b.clean_patched/src/msw/window.cpp	2025-05-28 09:28:45.976992400 +0200
@@ -286,14 +286,14 @@
 // This only works for the current (i.e. last received) mouse event.
 static bool wxIsTouchEventMSW()
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     // From https://learn.microsoft.com/en-us/windows/win32/tablet/system-events-and-mouse-messages
     const LONG_PTR MI_WP_SIGNATURE = 0xFF515700;
     const LONG_PTR SIGNATURE_MASK = 0xFFFFFF00;
     return (::GetMessageExtraInfo() & SIGNATURE_MASK) == MI_WP_SIGNATURE;
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 // ---------------------------------------------------------------------------
@@ -893,7 +893,7 @@
 
 bool wxWindowMSW::EnableTouchEvents(int eventsMask)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     // Static struct used when we need to use just a single configuration.
     GESTURECONFIG config = {0, 0, 0};
 
@@ -1011,9 +1011,9 @@
     }
 
     return true;
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 void wxWindowMSW::MSWUpdateUIState(int action, int state)
@@ -3489,7 +3489,7 @@
             }
             break;
 
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
         case WM_GESTURE:
         {
             HGESTUREINFO hGestureInfo = reinterpret_cast<HGESTUREINFO>(lParam);
@@ -3568,7 +3568,7 @@
             // handled, otherwise we still pass them to DefWindowProc().
             processed = HandleTouch(wParam, lParam);
             break;
-#endif
+#endif
 
         // CTLCOLOR messages are sent by children to query the parent for their
         // colors
@@ -6215,7 +6215,7 @@
                                    const wxPoint& pt,
                                    WXDWORD flags)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     event.SetEventObject(this);
     event.SetTimestamp(::GetMessageTime());
     event.SetPosition(pt);
@@ -6227,14 +6227,14 @@
         event.SetGestureEnd();
 
     return (flags & GF_BEGIN) != 0;
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandlePanGesture(const wxPoint& pt, WXDWORD flags)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_GESTURE_PAN
     wxPanGestureEvent event(GetId());
 
@@ -6255,16 +6255,16 @@
     s_previousLocation = pt;
 
     return HandleWindowEvent(event);
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleZoomGesture(const wxPoint& pt,
                                     WXDWORD fingerDistance,
                                     WXDWORD flags)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_GESTURE_ZOOM
     wxZoomGestureEvent event(GetId());
 
@@ -6297,16 +6297,16 @@
     s_previousLocation = pt;
 
     return HandleWindowEvent(event);
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleRotateGesture(const wxPoint& pt,
                                       WXDWORD angleArgument,
                                       WXDWORD flags)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_GESTURE_ROTATE
     wxRotateGestureEvent event(GetId());
 
@@ -6335,41 +6335,41 @@
     }
 
     return HandleWindowEvent(event);
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleTwoFingerTap(const wxPoint& pt, WXDWORD flags)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     // wxEVT_TWO_FINGER_TAP
     wxTwoFingerTapEvent event(GetId());
 
     InitGestureEvent(event, pt, flags);
 
     return HandleWindowEvent(event);
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandlePressAndTap(const wxPoint& pt, WXDWORD flags)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     wxPressAndTapEvent event(GetId());
 
     InitGestureEvent(event, pt, flags);
 
     return HandleWindowEvent(event);
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 bool wxWindowMSW::HandleTouch(WXWPARAM wParam, WXLPARAM lParam)
 {
-#if _WIN32_WINNT >= 0x0601
+#if _WIN32_WINNT >= 0x0601
     const unsigned count = LOWORD(wParam);
     const HTOUCHINPUT hTouchInput = (HTOUCHINPUT)lParam;
     wxVector<TOUCHINPUT> info(count);
@@ -6411,9 +6411,9 @@
     }
 
     return allHandled;
-#else
-    return false;
-#endif
+#else
+    return false;
+#endif
 }
 
 // ---------------------------------------------------------------------------
--- master-ed7a10efb8.clean/src/msw/datetimectrl.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-ed7a10efb8.clean_patched/src/msw/datetimectrl.cpp	2025-05-28 12:57:19.150544900 +0200
@@ -25,130 +25,76 @@
 #ifdef wxNEEDS_DATETIMEPICKCTRL
 
 #ifndef WX_PRECOMP
-    #include "wx/msw/wrapwin.h"
-    #include "wx/msw/wrapcctl.h" // include <commctrl.h> "properly"
-    #include "wx/msw/private.h"
-    #include "wx/dcclient.h"
+#include "wx/msw/wrapwin.h"
+#include "wx/msw/wrapcctl.h" // include <commctrl.h> "properly"
+#include "wx/msw/private.h"
+#include "wx/dcclient.h"
 #endif // WX_PRECOMP
 
 #include "wx/msw/private/datecontrols.h"
-#include "wx/msw/private/uilocale.h"
 
 // apparently some versions of mingw define these macros erroneously
 #ifndef DateTime_GetSystemtime
-    #define DateTime_GetSystemtime DateTime_GetSystemTime
+#define DateTime_GetSystemtime DateTime_GetSystemTime
 #endif
 
 #ifndef DateTime_SetSystemtime
-    #define DateTime_SetSystemtime DateTime_SetSystemTime
+#define DateTime_SetSystemtime DateTime_SetSystemTime
 #endif
 
 #ifndef DTM_GETIDEALSIZE
-    #define DTM_GETIDEALSIZE 0x100f
+#define DTM_GETIDEALSIZE 0x100f
 #endif
 
 // ============================================================================
 // wxDateTimePickerCtrl implementation
 // ============================================================================
 
-namespace wxMSWImpl
-{
-
-LRESULT CALLBACK
-DateTimeUDProc(HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam,
-               UINT_PTR uIdSubclass, DWORD_PTR WXUNUSED(dwRefData))
-{
-    switch ( nMsg )
-    {
-        case WM_PAINT:
-            // This is a bit ridiculous, but we have to explicitly paint the
-            // control here, even if all we do is to let it draw itself,
-            // because without this it may not draw the lower arrow at all when
-            // using WS_EX_COMPOSITED (it probably optimizes redraw by assuming
-            // that previously drawn part doesn't change, but this is not the
-            // case when compositing it used).
-            {
-                PAINTSTRUCT ps;
-                ::BeginPaint(hwnd, &ps);
-                ::DefSubclassProc(hwnd, WM_PAINT, (WPARAM)ps.hdc, 0);
-                ::EndPaint(hwnd, &ps);
-            }
-            return 0;
-
-        case WM_NCDESTROY:
-            ::RemoveWindowSubclass(hwnd, DateTimeUDProc, uIdSubclass);
-            break;
-    }
-
-    return ::DefSubclassProc(hwnd, nMsg, wParam, lParam);
-}
-
-} // namespace wxMSWImpl
-
 bool
-wxDateTimePickerCtrl::MSWCreateDateTimePicker(wxWindow *parent,
-                                              wxWindowID id,
-                                              const wxDateTime& dt,
-                                              const wxPoint& pos,
-                                              const wxSize& size,
-                                              long style,
-                                              const wxValidator& validator,
-                                              const wxString& name)
+wxDateTimePickerCtrl::MSWCreateDateTimePicker(wxWindow* parent,
+    wxWindowID id,
+    const wxDateTime& dt,
+    const wxPoint& pos,
+    const wxSize& size,
+    long style,
+    const wxValidator& validator,
+    const wxString& name)
 {
-    if ( !wxMSWDateControls::CheckInitialization() )
+    if (!wxMSWDateControls::CheckInitialization())
         return false;
 
     // initialize the base class
-    if ( !CreateControl(parent, id, pos, size, style, validator, name) )
+    if (!CreateControl(parent, id, pos, size, style, validator, name))
         return false;
 
     // create the native control
-    if ( !MSWCreateControl(DATETIMEPICK_CLASS, wxString(), pos, size) )
+    if (!MSWCreateControl(DATETIMEPICK_CLASS, wxString(), pos, size))
         return false;
 
-    if ( dt.IsValid() || MSWAllowsNone() )
+    if (dt.IsValid() || MSWAllowsNone())
         SetValue(dt);
     else
         SetValue(wxDateTime::Now());
 
-    // If have an up-down control, we must explicitly paint it ourselves
-    // because otherwise it may be not redrawn at all with WS_EX_COMPOSITED.
-    WinStruct<DATETIMEPICKERINFO> info;
-    ::SendMessage(GetHwnd(), DTM_GETDATETIMEPICKERINFO, 0, (LPARAM)&info);
-    if ( info.hwndUD )
-    {
-        ::SetWindowSubclass(info.hwndUD, wxMSWImpl::DateTimeUDProc, 0, 0);
-    }
-
     return true;
 }
 
-void wxDateTimePickerCtrl::MSWSetTimeFormat(wxLocaleInfo index)
-{
-    const wxString format = wxGetMSWDateTimeFormat(index);
-    if ( !format.empty() )
-    {
-        DateTime_SetFormat(GetHwnd(),
-                           static_cast<const wchar_t*>(format.t_str()));
-    }
-}
-
 void wxDateTimePickerCtrl::SetValue(const wxDateTime& dt)
 {
-    wxCHECK_RET( dt.IsValid() || MSWAllowsNone(),
-                    wxT("this control requires a valid date") );
+    wxCHECK_RET(dt.IsValid() || MSWAllowsNone(),
+        wxT("this control requires a valid date"));
 
     SYSTEMTIME st;
-    if ( dt.IsValid() )
+    if (dt.IsValid())
         dt.GetAsMSWSysTime(&st);
 
-    if ( !DateTime_SetSystemtime(GetHwnd(),
-                                 dt.IsValid() ? GDT_VALID : GDT_NONE,
-                                 &st) )
+    if (!DateTime_SetSystemtime(GetHwnd(),
+        dt.IsValid() ? GDT_VALID : GDT_NONE,
+        &st))
     {
         // The only expected failure is when the date is out of range but we
         // already checked for this above.
-        wxFAIL_MSG( wxT("Setting the calendar date unexpectedly failed.") );
+        wxFAIL_MSG(wxT("Setting the calendar date unexpectedly failed."));
 
         // In any case, skip updating m_date below.
         return;
@@ -166,21 +112,21 @@
 
 void wxDateTimePickerCtrl::MSWUpdateFormatIfNeeded(bool valid)
 {
-    if ( MSWAllowsNone() && !m_nullText.empty() && valid != m_date.IsValid() )
+    if (MSWAllowsNone() && !m_nullText.empty() && valid != m_date.IsValid())
         MSWUpdateFormat(valid);
 }
 
 void wxDateTimePickerCtrl::MSWUpdateFormat(bool valid)
 {
-    // We just use nullptr to reset to the default format when the date is valid,
+    // We just use NULL to reset to the default format when the date is valid,
     // as the control seems to remember whichever format was used when it was
     // created, i.e. this works both with and without wxDP_SHOWCENTURY.
 
     // Use a temporary variable to ensure that the code compiles in
     // wxUSE_UNICODE_UTF8 case, where t_str() doesn't return a pointer.
     const TCHAR* format;
-    if ( valid )
-        format = nullptr;
+    if (valid)
+        format = NULL;
     else
         format = m_nullText.t_str();
 
@@ -190,7 +136,7 @@
 void wxDateTimePickerCtrl::SetNullText(const wxString& text)
 {
     m_nullText = text;
-    if ( m_nullText.empty() )
+    if (m_nullText.empty())
     {
         // Using empty format doesn't work with the native control, it just
         // uses the default short date format in this case, so set the format
@@ -215,7 +161,7 @@
     }
 
     // Apply it immediately if we don't have any value right now.
-    if ( !m_date.IsValid() )
+    if (!m_date.IsValid())
         MSWUpdateFormat(false);
 }
 
@@ -223,63 +169,66 @@
 {
     wxSize size;
 
-    // Use DTM_GETIDEALSIZE to ask the control itself to compute its ideal
-    // size, but we can't use it with DTS_SHOWNONE because handling of
-    // this flag is completely broken (up to at least Window 10 20H2): it's
-    // not just ignored, but we get completely wrong results when this flag
-    // is on, e.g. the returned width is less than the width without it or
-    // much greater than the real value after a DPI change (and growing
-    // with every new change, even when repeatedly switching between the
-    // same DPI values, e.g. dragging a window between 2 monitors with
-    // different scaling). Moreover, note that even without DTS_SHOWNONE,
-    // DTM_GETIDEALSIZE still returns wrong results for the height after a
-    // DPI change, so we never use the vertical component of the value
-    // returned by it.
-    //
-    // Unfortunately, resetting this style doesn't work either, so we have
-    // to create a whole new window just for this, which is pretty wasteful
-    // but seems unavoidable.
-    HWND hwnd;
-    if ( MSWAllowsNone() )
-    {
-        hwnd = ::CreateWindow
-                 (
-                    DATETIMEPICK_CLASS,
-                    wxT(""),
-                    ::GetWindowLong(GetHwnd(), GWL_STYLE) & ~DTS_SHOWNONE,
-                    0, 0, 1, 1,
-                    GetHwndOf(m_parent),
-                    0,
-                    wxGetInstance(),
-                    nullptr
-                 );
-        wxCHECK_MSG( hwnd, wxSize(),
-                     wxS("SysDateTimePick32 creation unexpected failed") );
-
-        wxSetWindowFont(hwnd, GetFont());
-    }
-    else
-    {
-        hwnd = GetHwnd();
-    }
-
-    // Also work around https://bugs.winehq.org/show_bug.cgi?id=44680 by
-    // checking for the return value: even if all "real" MSW systems do support
-    // this message, Wine does not, even when it's configured to return Vista
-    // or later version to the application, and returns FALSE for it.
+    // Use DTM_GETIDEALSIZE to ask the control itself to compute its ideal size.
     SIZE idealSize = { 0, 0 };
-    if ( ::SendMessage(hwnd, DTM_GETIDEALSIZE, 0, (LPARAM)&idealSize) )
+    if (wxGetWinVersion() >= wxWinVersion_Vista)
     {
-        size.x = idealSize.cx;
-        size.y = GetCharHeight();
-    }
-
-    if ( hwnd != GetHwnd() )
-    {
-        ::DestroyWindow(hwnd);
+        // We can't use DTM_GETIDEALSIZE with DTS_SHOWNONE because handling of
+        // this flag is completely broken (up to at least Window 10 20H2): it's
+        // not just ignored, but we get completely wrong results when this flag
+        // is on, e.g. the returned width is less than the width without it or
+        // much greater than the real value after a DPI change (and growing
+        // with every new change, even when repeatedly switching between the
+        // same DPI values, e.g. dragging a window between 2 monitors with
+        // different scaling). Moreover, note that even without DTS_SHOWNONE,
+        // DTM_GETIDEALSIZE still returns wrong results for the height after a
+        // DPI change, so we never use the vertical component of the value
+        // returned by it.
+        //
+        // Unfortunately, resetting this style doesn't work either, so we have
+        // to create a whole new window just for this, which is pretty wasteful
+        // but seems unavoidable.
+        HWND hwnd;
+        if (MSWAllowsNone())
+        {
+            hwnd = ::CreateWindow
+            (
+                DATETIMEPICK_CLASS,
+                wxT(""),
+                ::GetWindowLong(GetHwnd(), GWL_STYLE) & ~DTS_SHOWNONE,
+                0, 0, 1, 1,
+                GetHwndOf(m_parent),
+                0,
+                wxGetInstance(),
+                NULL
+            );
+            wxCHECK_MSG(hwnd, wxSize(),
+                wxS("SysDateTimePick32 creation unexpected failed"));
+
+            wxSetWindowFont(hwnd, GetFont());
+        }
+        else
+        {
+            hwnd = GetHwnd();
+        }
+
+        // Also work around https://bugs.winehq.org/show_bug.cgi?id=44680 by
+        // checking for the return value: even if all "real" MSW systems do support
+        // this message, Wine does not, even when it's configured to return Vista
+        // or later version to the application, and returns FALSE for it.
+        if (::SendMessage(hwnd, DTM_GETIDEALSIZE, 0, (LPARAM)&idealSize))
+        {
+            size.x = idealSize.cx;
+            size.y = GetCharHeight();
+        }
+
+        if (hwnd != GetHwnd())
+        {
+            ::DestroyWindow(hwnd);
+        }
     }
 
-    if ( !size.x ) // Compute the size ourselves.
+    if (!idealSize.cx) // Compute the size ourselves.
     {
         // Use the same native format as the underlying native control.
 #if wxUSE_INTL
@@ -301,7 +250,7 @@
     }
 
     // Account for the checkbox.
-    if ( MSWAllowsNone() )
+    if (MSWAllowsNone())
     {
         // The extra 8px here was determined heuristically as the value which
         // results in the same layout with and without DTS_SHOWNONE under
@@ -319,23 +268,23 @@
 }
 
 bool
-wxDateTimePickerCtrl::MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM *result)
+wxDateTimePickerCtrl::MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM* result)
 {
-    NMHDR* hdr = (NMHDR *)lParam;
-    switch ( hdr->code )
+    NMHDR* hdr = (NMHDR*)lParam;
+    switch (hdr->code)
     {
-        case DTN_DATETIMECHANGE:
-            const NMDATETIMECHANGE& dtch = *(NMDATETIMECHANGE*)(hdr);
-
-            // Update the format before showing the new date if necessary.
-            MSWUpdateFormatIfNeeded(dtch.dwFlags == GDT_VALID);
+    case DTN_DATETIMECHANGE:
+        const NMDATETIMECHANGE& dtch = *(NMDATETIMECHANGE*)(hdr);
 
-            if ( MSWOnDateTimeChange(dtch) )
-            {
-                *result = 0;
-                return true;
-            }
-            break;
+        // Update the format before showing the new date if necessary.
+        MSWUpdateFormatIfNeeded(dtch.dwFlags == GDT_VALID);
+
+        if (MSWOnDateTimeChange(dtch))
+        {
+            *result = 0;
+            return true;
+        }
+        break;
     }
 
     return wxDateTimePickerCtrlBase::MSWOnNotify(idCtrl, lParam, result);
--- master-ed7a10efb8.clean/include/wx/msw/datetimectrl.h	2025-05-26 18:04:50.000000000 +0200
+++ master-ed7a10efb8.clean_patched/include/wx/msw/datetimectrl.h	2025-05-28 12:59:21.931257800 +0200
@@ -23,37 +23,34 @@
 {
 public:
     // set/get the date
-    virtual void SetValue(const wxDateTime& dt) override;
-    virtual wxDateTime GetValue() const override;
+    virtual void SetValue(const wxDateTime& dt) wxOVERRIDE;
+    virtual wxDateTime GetValue() const wxOVERRIDE;
 
-    virtual void SetNullText(const wxString& text) override;
+    virtual void SetNullText(const wxString& text) wxOVERRIDE;
 
     // returns true if the platform should explicitly apply a theme border
-    virtual bool CanApplyThemeBorder() const override { return false; }
+    virtual bool CanApplyThemeBorder() const wxOVERRIDE { return false; }
 
-    virtual bool MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM *result) override;
+    virtual bool MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM* result) wxOVERRIDE;
 
 protected:
-    virtual wxBorder GetDefaultBorder() const override { return wxBORDER_NONE; }
-    virtual wxSize DoGetBestSize() const override;
+    virtual wxBorder GetDefaultBorder() const wxOVERRIDE { return wxBORDER_NONE; }
+    virtual wxSize DoGetBestSize() const wxOVERRIDE;
 
     // Helper for the derived classes Create(): creates a native control with
     // the specified attributes.
-    bool MSWCreateDateTimePicker(wxWindow *parent,
-                                 wxWindowID id,
-                                 const wxDateTime& dt,
-                                 const wxPoint& pos,
-                                 const wxSize& size,
-                                 long style,
-                                 const wxValidator& validator,
-                                 const wxString& name);
+    bool MSWCreateDateTimePicker(wxWindow* parent,
+        wxWindowID id,
+        const wxDateTime& dt,
+        const wxPoint& pos,
+        const wxSize& size,
+        long style,
+        const wxValidator& validator,
+        const wxString& name);
 
 #if wxUSE_INTL
     // Override to return the date/time format used by this control.
     virtual wxLocaleInfo MSWGetFormat() const = 0;
-
-    // Set the format used by the native control.
-    void MSWSetTimeFormat(wxLocaleInfo index);
 #endif // wxUSE_INTL
 
     // Override to indicate whether we can have no date at all.
diff -Nur master-6d0218a996.clean/src/msw/datectrl.cpp master-6d0218a996.clean_patched/src/msw/datectrl.cpp
--- master-6d0218a996.clean/src/msw/datectrl.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-6d0218a996.clean_patched/src/msw/datectrl.cpp	2025-05-28 13:40:53.946790000 +0200
@@ -62,12 +62,6 @@
     bool ok = MSWCreateDateTimePicker(parent, id, dt,
                                       pos, size, style,
                                       validator, name);
-#if wxUSE_INTL
-    if (ok)
-    {
-        MSWSetTimeFormat(wxLOCALE_SHORT_DATE_FMT);
-    }
-#endif
     return ok;
 }
 
diff -Nur master-6d0218a996.clean/src/msw/timectrl.cpp master-6d0218a996.clean_patched/src/msw/timectrl.cpp
--- master-6d0218a996.clean/src/msw/timectrl.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-6d0218a996.clean_patched/src/msw/timectrl.cpp	2025-05-28 13:41:39.633220900 +0200
@@ -50,10 +50,6 @@
                                   validator, name) )
         return false;
 
-#if wxUSE_INTL
-    MSWSetTimeFormat(wxLOCALE_TIME_FMT);
-#endif
-
     return true;
 }
 
--- master-4b5cb6d586.clean/include/wx/msw/progdlg.h	2025-05-26 18:04:50.000000000 +0200
+++ master-4b5cb6d586.clean_patched/include/wx/msw/progdlg.h	2025-05-28 16:23:52.480629700 +0200
@@ -17,48 +17,48 @@
 {
 public:
     wxProgressDialog(const wxString& title, const wxString& message,
-                     int maximum = 100,
-                     wxWindow *parent = nullptr,
-                     int style = wxPD_APP_MODAL | wxPD_AUTO_HIDE);
+        int maximum = 100,
+        wxWindow* parent = NULL,
+        int style = wxPD_APP_MODAL | wxPD_AUTO_HIDE);
 
     virtual ~wxProgressDialog();
 
-    virtual bool Update(int value, const wxString& newmsg = wxEmptyString, bool *skip = nullptr) override;
-    virtual bool Pulse(const wxString& newmsg = wxEmptyString, bool *skip = nullptr) override;
+    virtual bool Update(int value, const wxString& newmsg = wxEmptyString, bool* skip = NULL) wxOVERRIDE;
+    virtual bool Pulse(const wxString& newmsg = wxEmptyString, bool* skip = NULL) wxOVERRIDE;
 
-    virtual void Resume() override;
+    virtual void Resume() wxOVERRIDE;
 
-    virtual int GetValue() const override;
-    virtual wxString GetMessage() const override;
+    virtual int GetValue() const wxOVERRIDE;
+    virtual wxString GetMessage() const wxOVERRIDE;
 
-    virtual void SetRange(int maximum) override;
+    virtual void SetRange(int maximum) wxOVERRIDE;
 
     // Return whether "Cancel" or "Skip" button was pressed, always return
     // false if the corresponding button is not shown.
-    virtual bool WasSkipped() const override;
-    virtual bool WasCancelled() const override;
+    virtual bool WasSkipped() const wxOVERRIDE;
+    virtual bool WasCancelled() const wxOVERRIDE;
 
-    virtual void SetTitle(const wxString& title) override;
-    virtual wxString GetTitle() const override;
+    virtual void SetTitle(const wxString& title) wxOVERRIDE;
+    virtual wxString GetTitle() const wxOVERRIDE;
 
-    virtual void SetIcons(const wxIconBundle& icons) override;
-    virtual void DoMoveWindow(int x, int y, int width, int height) override;
-    virtual void DoGetPosition(int *x, int *y) const override;
-    virtual void DoGetSize(int *width, int *height) const override;
-    virtual void Fit() override;
+    virtual void SetIcons(const wxIconBundle& icons) wxOVERRIDE;
+    virtual void DoMoveWindow(int x, int y, int width, int height) wxOVERRIDE;
+    virtual void DoGetPosition(int* x, int* y) const wxOVERRIDE;
+    virtual void DoGetSize(int* width, int* height) const wxOVERRIDE;
+    virtual void Fit() wxOVERRIDE;
 
-    virtual bool Show( bool show = true ) override;
+    virtual bool Show(bool show = true) wxOVERRIDE;
 
     // Must provide overload to avoid hiding it (and warnings about it)
-    virtual void Update() override { wxGenericProgressDialog::Update(); }
+    virtual void Update() wxOVERRIDE { wxGenericProgressDialog::Update(); }
 
-    virtual WXWidget GetHandle() const override;
+    virtual WXWidget GetHandle() const wxOVERRIDE;
 
 private:
     // Common part of Update() and Pulse().
     //
     // Returns false if the user requested cancelling the dialog.
-    bool DoNativeBeforeUpdate(bool *skip);
+    bool DoNativeBeforeUpdate(bool* skip);
 
     // Dispatch the pending events to let the windows to update, just as the
     // generic version does. This is done as part of DoNativeBeforeUpdate().
@@ -73,14 +73,14 @@
     wxRect GetTaskDialogRect() const;
 
 
-    wxProgressDialogTaskRunner *m_taskDialogRunner;
+    wxProgressDialogTaskRunner* m_taskDialogRunner;
 
-    wxProgressDialogSharedData *m_sharedData;
+    wxProgressDialogSharedData* m_sharedData;
 
     // Store the message and title we currently use to be able to return it
     // from Get{Message,Title}()
     wxString m_message,
-             m_title;
+        m_title;
 
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxProgressDialog);
 };
--- master-4b5cb6d586.clean/src/msw/uilocale.cpp	2025-05-28 14:59:28.250182800 +0200
+++ master-4b5cb6d586.clean_patched/src/msw/uilocale.cpp	2025-05-28 18:31:18.551739500 +0200
@@ -441,7 +441,8 @@
     void Use() override
     {
         wxDynamicLibrary kernel32(wxT("kernel32.dll"), wxDL_VERBATIM | wxDL_DEFAULT);
-	BOOL (WINAPI *pfnSetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG) =
+        if (wxGetWinVersion() >= wxWinVersion_7) {
+	    BOOL (WINAPI *pfnSetThreadPreferredUILanguages)(DWORD, PCZZWSTR, PULONG) =
              (BOOL (*)(DWORD, PCZZWSTR, PULONG))kernel32.GetSymbol(wxT("SetThreadPreferredUILanguages"));
 
         // Construct a double NUL-terminated buffer.
@@ -456,6 +457,7 @@
 
         if (pfnSetThreadPreferredUILanguages)
             pfnSetThreadPreferredUILanguages(MUI_LANGUAGE_NAME, buf, &num);
+        }
     }
 
     wxString GetName() const override
--- master-4b5cb6d586.clean/src/msw/app.cpp	2025-05-26 18:04:50.000000000 +0200
+++ master-4b5cb6d586.clean_patched/src/msw/app.cpp	2025-05-28 18:46:24.732457600 +0200
@@ -497,7 +497,7 @@
 
     if ( !wxSystemOptions::GetOptionInt("msw.no-manifest-check") )
     {
-        if ( GetComCtl32Version() < 610 )
+        if ( GetComCtl32Version() < 500 )
         {
             // Check if we have wx resources in this program: this is not
             // mandatory, but recommended and could be the simplest way to
--- wxWidgets-3.3.0/src/msw/progdlg.cpp	2025-06-05 18:50:05.000000000 +0200
+++ wxWidgets-3.3.0_patched/src/msw/progdlg.cpp	2025-04-24 21:21:09.000000000 +0200
@@ -35,6 +35,8 @@
 
 using namespace wxMSWMessageDialog;
 
+#ifdef wxHAS_MSW_TASKDIALOG
+
 // ----------------------------------------------------------------------------
 // Constants
 // ----------------------------------------------------------------------------
@@ -77,7 +79,7 @@
         m_skipped = false;
         m_msgChangeElementText = TDM_UPDATE_ELEMENT_TEXT;
         m_notifications = 0;
-        m_parent = nullptr;
+        m_parent = NULL;
     }
 
     wxCriticalSection m_cs;
@@ -159,7 +161,7 @@
 private:
     wxProgressDialogSharedData m_sharedData;
 
-    virtual void* Entry() override;
+    virtual void* Entry() wxOVERRIDE;
 
     static HRESULT CALLBACK TaskDialogCallbackProc(HWND hwnd,
                                                    UINT uNotification,
@@ -182,7 +184,7 @@
     }
 
 protected:
-    virtual void OnNextIteration() override
+    virtual void OnNextIteration() wxOVERRIDE
     {
         wxCriticalSectionLocker locker(m_data.m_cs);
 
@@ -297,7 +299,7 @@
 
     if ( sharedData->m_notifications & wxSPDD_WINDOW_MOVED )
     {
-        ::SetWindowPos(hwnd, nullptr, sharedData->m_winPosition.x, sharedData->m_winPosition.y,
+        ::SetWindowPos(hwnd, NULL, sharedData->m_winPosition.x, sharedData->m_winPosition.y,
                        -1, -1, // ignored
                        SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER);
     }
@@ -380,6 +382,8 @@
 
 } // anonymous namespace
 
+#endif // wxHAS_MSW_TASKDIALOG
+
 // ============================================================================
 // wxProgressDialog implementation
 // ============================================================================
@@ -390,11 +394,12 @@
                                     wxWindow *parent,
                                     int style )
     : wxGenericProgressDialog(),
-      m_taskDialogRunner(nullptr),
-      m_sharedData(nullptr),
+      m_taskDialogRunner(NULL),
+      m_sharedData(NULL),
       m_message(message),
       m_title(title)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         SetTopParent(parent);
@@ -407,12 +412,14 @@
 
         return;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     Create(title, message, maximum, parent, style);
 }
 
 wxProgressDialog::~wxProgressDialog()
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( !m_taskDialogRunner )
         return;
 
@@ -465,10 +472,12 @@
     ReenableOtherWindows();
 
     delete m_taskDialogRunner;
+#endif // wxHAS_MSW_TASKDIALOG
 }
 
 bool wxProgressDialog::Update(int value, const wxString& newmsg, bool *skip)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         if ( !DoNativeBeforeUpdate(skip) )
@@ -536,12 +545,14 @@
         loop.Run();
         return true;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::Update( value, newmsg, skip );
 }
 
 bool wxProgressDialog::Pulse(const wxString& newmsg, bool *skip)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         if ( !DoNativeBeforeUpdate(skip) )
@@ -571,12 +582,14 @@
 
         return m_sharedData->m_state != Canceled;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::Pulse( newmsg, skip );
 }
 
 void wxProgressDialog::DispatchEvents()
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     // No need for HasNativeTaskDialog() check, we're only called when this is
     // the case.
 
@@ -585,10 +598,14 @@
     // other user actions while the dialog is shown.
     wxEventLoop::GetActive()->
         YieldFor(wxEVT_CATEGORY_ALL & ~wxEVT_CATEGORY_USER_INPUT);
+#else // !wxHAS_MSW_TASKDIALOG
+    wxFAIL_MSG( "unreachable" );
+#endif // wxHAS_MSW_TASKDIALOG/!wxHAS_MSW_TASKDIALOG
 }
 
 bool wxProgressDialog::DoNativeBeforeUpdate(bool *skip)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     DispatchEvents();
 
     wxCriticalSectionLocker locker(m_sharedData->m_cs);
@@ -607,12 +624,19 @@
         m_timeStop = m_sharedData->m_timeStop;
 
     return m_sharedData->m_state != Canceled;
+#else // !wxHAS_MSW_TASKDIALOG
+    wxUnusedVar(skip);
+    wxFAIL_MSG( "unreachable" );
+
+    return false;
+#endif // wxHAS_MSW_TASKDIALOG/!wxHAS_MSW_TASKDIALOG
 }
 
 void wxProgressDialog::Resume()
 {
     wxGenericProgressDialog::Resume();
 
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         HWND hwnd;
@@ -644,40 +668,48 @@
         // thread would simply fail.
         ::BringWindowToTop(hwnd);
     }
+#endif // wxHAS_MSW_TASKDIALOG
 }
 
 WXWidget wxProgressDialog::GetHandle() const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         wxCriticalSectionLocker locker(m_sharedData->m_cs);
         return m_sharedData->m_hwnd;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::GetHandle();
 }
 
 int wxProgressDialog::GetValue() const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         wxCriticalSectionLocker locker(m_sharedData->m_cs);
         return m_sharedData->m_value;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::GetValue();
 }
 
 wxString wxProgressDialog::GetMessage() const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
         return m_message;
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::GetMessage();
 }
 
 void wxProgressDialog::SetRange(int maximum)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         SetMaximum(maximum);
@@ -689,12 +721,14 @@
 
         return;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::SetRange( maximum );
 }
 
 bool wxProgressDialog::WasSkipped() const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         if ( !m_sharedData )
@@ -706,23 +740,27 @@
         wxCriticalSectionLocker locker(m_sharedData->m_cs);
         return m_sharedData->m_skipped;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::WasSkipped();
 }
 
 bool wxProgressDialog::WasCancelled() const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         wxCriticalSectionLocker locker(m_sharedData->m_cs);
         return m_sharedData->m_state == Canceled;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::WasCancelled();
 }
 
 void wxProgressDialog::SetTitle(const wxString& title)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         m_title = title;
@@ -734,20 +772,24 @@
             m_sharedData->m_notifications |= wxSPDD_TITLE_CHANGED;
         }
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::SetTitle(title);
 }
 
 wxString wxProgressDialog::GetTitle() const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
         return m_title;
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::GetTitle();
 }
 
 void wxProgressDialog::SetIcons(const wxIconBundle& icons)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         m_icons = icons; // We can't just call to parent's SetIcons()
@@ -774,12 +816,14 @@
 
         return;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::SetIcons(icons);
 }
 
 void wxProgressDialog::DoMoveWindow(int x, int y, int width, int height)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         if ( m_sharedData )
@@ -791,6 +835,7 @@
 
         return;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::DoMoveWindow(x, y, width, height);
 }
@@ -799,17 +844,22 @@
 {
     wxRect r;
 
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( m_sharedData )
     {
         wxCriticalSectionLocker locker(m_sharedData->m_cs);
         r = wxRectFromRECT(wxGetWindowRect(m_sharedData->m_hwnd));
     }
+#else // !wxHAS_MSW_TASKDIALOG
+    wxFAIL_MSG( "unreachable" );
+#endif // wxHAS_MSW_TASKDIALOG/!wxHAS_MSW_TASKDIALOG
 
     return r;
 }
 
 void wxProgressDialog::DoGetPosition(int *x, int *y) const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         const wxRect r = GetTaskDialogRect();
@@ -820,12 +870,14 @@
 
         return;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::DoGetPosition(x, y);
 }
 
 void wxProgressDialog::DoGetSize(int *width, int *height) const
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         const wxRect r = GetTaskDialogRect();
@@ -836,12 +888,14 @@
 
         return;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::DoGetSize(width, height);
 }
 
 void wxProgressDialog::Fit()
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         wxCriticalSectionLocker locker(m_sharedData->m_cs);
@@ -852,12 +906,14 @@
         // Don't change the message, but pretend that it did change.
         m_sharedData->m_notifications |= wxSPDD_MESSAGE_CHANGED;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     wxGenericProgressDialog::Fit();
 }
 
 bool wxProgressDialog::Show(bool show)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     if ( HasNativeTaskDialog() )
     {
         // The dialog can't be hidden at all and showing it again after it had
@@ -925,12 +981,14 @@
         // Do not show the underlying dialog.
         return false;
     }
+#endif // wxHAS_MSW_TASKDIALOG
 
     return wxGenericProgressDialog::Show( show );
 }
 
 void wxProgressDialog::UpdateExpandedInformation(int value)
 {
+#ifdef wxHAS_MSW_TASKDIALOG
     unsigned long elapsedTime;
     unsigned long estimatedTime;
     unsigned long remainingTime;
@@ -983,12 +1041,17 @@
         m_sharedData->m_expandedInformation = expandedInformation;
         m_sharedData->m_notifications |= wxSPDD_EXPINFO_CHANGED;
     }
+#else // !wxHAS_MSW_TASKDIALOG
+    wxUnusedVar(value);
+#endif // wxHAS_MSW_TASKDIALOG/!wxHAS_MSW_TASKDIALOG
 }
 
 // ----------------------------------------------------------------------------
 // wxProgressDialogTaskRunner and related methods
 // ----------------------------------------------------------------------------
 
+#ifdef wxHAS_MSW_TASKDIALOG
+
 void* wxProgressDialogTaskRunner::Entry()
 {
     WinStruct<TASKDIALOGCONFIG> tdc;
@@ -1042,10 +1105,10 @@
 
     TaskDialogIndirect_t taskDialogIndirect = GetTaskDialogIndirectFunc();
     if ( !taskDialogIndirect )
-        return nullptr;
+        return NULL;
 
     int msAns;
-    HRESULT hr = taskDialogIndirect(&tdc, &msAns, nullptr, nullptr);
+    HRESULT hr = taskDialogIndirect(&tdc, &msAns, NULL, NULL);
     if ( FAILED(hr) )
         wxLogApiError( "TaskDialogIndirect", hr );
 
@@ -1053,7 +1116,7 @@
     // Update(), wake it up so that it checks our status again.
     wxWakeUpIdle();
 
-    return nullptr;
+    return NULL;
 }
 
 // static
@@ -1205,4 +1268,6 @@
     return S_OK;
 }
 
+#endif // wxHAS_MSW_TASKDIALOG
+
 #endif // wxUSE_PROGRESSDLG && wxUSE_THREADS
